/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * API Compta
 * API REST pour la gestion de compta
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import {
  computed,
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

import { customAxios } from '../../../../api/axios-instance';
export interface UpdateUserRequest {
  email?: string;
  /**
   * @minLength 2
   * @maxLength 100
   */
  firstName?: string;
  /**
   * @minLength 2
   * @maxLength 100
   */
  lastName?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  phone?: string;
}

export interface UserResponse {
  id?: number;
  username?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  phone?: string;
  isActive?: boolean;
  isLocked?: boolean;
  failedLoginAttempts?: number;
  lastLoginAt?: string;
  createdAt?: string;
  updatedAt?: string;
  roles?: string[];
}

export interface UpdateSocieteRequest {
  /**
   * @minLength 2
   * @maxLength 255
   */
  raisonSociale?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  codeTva?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  codeDouane?: string;
  /**
   * @minLength 0
   * @maxLength 50
   */
  registreCommerce?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  formeJuridique?: string;
  capitalSocial?: number;
  dateCreation?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  adresse?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  ville?: string;
  /**
   * @minLength 0
   * @maxLength 10
   */
  codePostal?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  telephone?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  fax?: string;
  email?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  siteWeb?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  activite?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  secteur?: string;
  isActive?: boolean;
}

export interface Societes {
  id?: number;
  /**
   * @minLength 0
   * @maxLength 255
   */
  raisonSociale: string;
  /**
   * @minLength 0
   * @maxLength 13
   */
  matriculeFiscale: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  codeTva?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  codeDouane?: string;
  /**
   * @minLength 0
   * @maxLength 50
   */
  registreCommerce?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  formeJuridique?: string;
  capitalSocial?: number;
  dateCreation?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  adresse?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  ville?: string;
  /**
   * @minLength 0
   * @maxLength 10
   */
  codePostal?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  telephone?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  fax?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  email?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  siteWeb?: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  activite?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  secteur?: string;
  isActive?: boolean;
  createdAt?: string;
  updatedAt?: string;
  createdBy?: number;
  updatedBy?: number;
}

export interface ChangePasswordRequest {
  /** @minLength 1 */
  currentPassword: string;
  /**
   * @minLength 8
   * @maxLength 2147483647
   */
  newPassword: string;
  /** @minLength 1 */
  confirmPassword: string;
}

export interface Users {
  id?: number;
  /**
   * @minLength 0
   * @maxLength 100
   */
  username: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  email: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  password: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  firstName?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  lastName?: string;
  /**
   * @minLength 0
   * @maxLength 20
   */
  phone?: string;
  isActive?: boolean;
  isLocked?: boolean;
  failedLoginAttempts?: number;
  lastLoginAt?: string;
  passwordChangedAt?: string;
  createdAt?: string;
  updatedAt?: string;
  createdBy?: number;
  updatedBy?: number;
}

export interface AssignRoleRequest {
  /** @minLength 1 */
  roleName: string;
}

export type CreateUserRequestRolesItem = typeof CreateUserRequestRolesItem[keyof typeof CreateUserRequestRolesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateUserRequestRolesItem = {
  ADMIN: 'ADMIN',
  COMPTABLE: 'COMPTABLE',
  SOCIETE: 'SOCIETE',
  EMPLOYEE: 'EMPLOYEE',
} as const;

export interface CreateUserRequest {
  /**
   * @minLength 3
   * @maxLength 100
   */
  username: string;
  /** @minLength 1 */
  email: string;
  /**
   * @minLength 8
   * @maxLength 2147483647
   */
  password: string;
  firstName?: string;
  lastName?: string;
  phone?: string;
  roles?: CreateUserRequestRolesItem[];
}

export interface CreateSocieteRequest {
  /**
   * @minLength 0
   * @maxLength 255
   */
  raisonSociale: string;
  /**
   * @minLength 1
   * @pattern \d{7}[A-Z]\d{3}
   */
  matriculeFiscale: string;
  codeTva?: string;
  codeDouane?: string;
  registreCommerce?: string;
  formeJuridique?: string;
  capitalSocial?: number;
  dateCreation?: string;
  adresse?: string;
  ville?: string;
  codePostal?: string;
  telephone?: string;
  fax?: string;
  email?: string;
  siteWeb?: string;
  activite?: string;
  secteur?: string;
}

export interface UserSocieteRequest {
  userId: number;
  societeId: number;
  isOwner?: boolean;
  dateDebut: string;
  dateFin?: string;
}

export interface ComptableSocieteRequest {
  userId: number;
  societeId: number;
  dateDebut: string;
  dateFin?: string;
}

export interface CreateEmployeeRequest {
  userId: number;
  societeId: number;
  matriculeEmployee?: string;
  /** @minLength 1 */
  poste: string;
  departement?: string;
  dateEmbauche?: string;
  dateFinContrat?: string;
  typeContrat?: string;
}

export interface AuthResponse {
  token?: string;
  refreshToken?: string;
  type?: string;
  userId?: number;
  username?: string;
  email?: string;
  roles?: string[];
}

export interface LoginRequest {
  /** @minLength 1 */
  username: string;
  /** @minLength 1 */
  password: string;
}

export interface Employees {
  id?: number;
  userId: number;
  societeId: number;
  /**
   * @minLength 0
   * @maxLength 50
   */
  matriculeEmployee?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  poste?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  departement?: string;
  dateEmbauche?: string;
  dateFinContrat?: string;
  /**
   * @minLength 0
   * @maxLength 50
   */
  typeContrat?: string;
  isActive?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

export interface AuthLogResponse {
  id?: number;
  userId?: number;
  username?: string;
  action?: string;
  ipAddress?: string;
  userAgent?: string;
  details?: string;
  createdAt?: string;
}

export type RefreshTokenParams = {
refreshToken: string;
};

export type LogoutParams = {
refreshToken?: string;
};

export type GetAllLogsParams = {
limit?: number;
};

export type GetUserLogsParams = {
limit?: number;
};

export type GetLogsByActionParams = {
limit?: number;
};

/**
 * Get user details by ID (ADMIN or COMPTABLE)
 * @summary Get user by ID
 */
export const getUserById = (
    id: MaybeRef<number>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customAxios<UserResponse>(
      {url: `/api/users/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserByIdQueryKey = (id?: MaybeRef<number>,) => {
    return [
    'api','users',id
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetUserByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> 
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = unknown


/**
 * @summary Get user by ID
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = unknown>(
 id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Update user information (ADMIN only)
 * @summary Update user
 */
export const updateUser = (
    id: MaybeRef<number>,
    updateUserRequest: MaybeRef<UpdateUserRequest>,
 ) => {
      id = unref(id);
updateUserRequest = unref(updateUserRequest);
      
      return customAxios<UserResponse>(
      {url: `/api/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRequest
    },
      );
    }
  


export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {id: number;data: UpdateUserRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateUser(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = unknown

    /**
 * @summary Update user
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{id: number;data: UpdateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {id: number;data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete user (ADMIN only)
 * @summary Delete user
 */
export const deleteUser = (
    id: MaybeRef<number>,
 ) => {
      id = unref(id);
      
      return customAxios<void>(
      {url: `/api/users/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    /**
 * @summary Delete user
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Unlock user account (ADMIN only)
 * @summary Unlock user
 */
export const unlockUser = (
    id: MaybeRef<number>,
 ) => {
      id = unref(id);
      
      return customAxios<void>(
      {url: `/api/users/${id}/unlock`, method: 'PUT'
    },
      );
    }
  


export const getUnlockUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['unlockUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof unlockUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  unlockUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UnlockUserMutationResult = NonNullable<Awaited<ReturnType<typeof unlockUser>>>
    
    export type UnlockUserMutationError = unknown

    /**
 * @summary Unlock user
 */
export const useUnlockUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof unlockUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof unlockUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getUnlockUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Deactivate user account (ADMIN only)
 * @summary Deactivate user
 */
export const deactivateUser = (
    id: MaybeRef<number>,
 ) => {
      id = unref(id);
      
      return customAxios<void>(
      {url: `/api/users/${id}/deactivate`, method: 'PUT'
    },
      );
    }
  


export const getDeactivateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deactivateUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['deactivateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deactivateUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deactivateUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeactivateUserMutationResult = NonNullable<Awaited<ReturnType<typeof deactivateUser>>>
    
    export type DeactivateUserMutationError = unknown

    /**
 * @summary Deactivate user
 */
export const useDeactivateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deactivateUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deactivateUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeactivateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Activate user account (ADMIN only)
 * @summary Activate user
 */
export const activateUser = (
    id: MaybeRef<number>,
 ) => {
      id = unref(id);
      
      return customAxios<void>(
      {url: `/api/users/${id}/activate`, method: 'PUT'
    },
      );
    }
  


export const getActivateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateUser>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof activateUser>>, TError,{id: number}, TContext> => {

const mutationKey = ['activateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof activateUser>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  activateUser(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ActivateUserMutationResult = NonNullable<Awaited<ReturnType<typeof activateUser>>>
    
    export type ActivateUserMutationError = unknown

    /**
 * @summary Activate user
 */
export const useActivateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof activateUser>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof activateUser>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getActivateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get company details by ID
 * @summary Get societe by ID
 */
export const getSocieteById = (
    id: MaybeRef<number>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customAxios<Societes>(
      {url: `/api/societes/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetSocieteByIdQueryKey = (id?: MaybeRef<number>,) => {
    return [
    'api','societes',id
    ] as const;
    }

    
export const getGetSocieteByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSocieteById>>, TError = unknown>(id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetSocieteByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSocieteById>>> = ({ signal }) => getSocieteById(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSocieteById>>, TError, TData> 
}

export type GetSocieteByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSocieteById>>>
export type GetSocieteByIdQueryError = unknown


/**
 * @summary Get societe by ID
 */

export function useGetSocieteById<TData = Awaited<ReturnType<typeof getSocieteById>>, TError = unknown>(
 id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSocieteByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Update company information (ADMIN or COMPTABLE)
 * @summary Update societe
 */
export const updateSociete = (
    id: MaybeRef<number>,
    updateSocieteRequest: MaybeRef<UpdateSocieteRequest>,
 ) => {
      id = unref(id);
updateSocieteRequest = unref(updateSocieteRequest);
      
      return customAxios<Societes>(
      {url: `/api/societes/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateSocieteRequest
    },
      );
    }
  


export const getUpdateSocieteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSociete>>, TError,{id: number;data: UpdateSocieteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSociete>>, TError,{id: number;data: UpdateSocieteRequest}, TContext> => {

const mutationKey = ['updateSociete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSociete>>, {id: number;data: UpdateSocieteRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateSociete(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSocieteMutationResult = NonNullable<Awaited<ReturnType<typeof updateSociete>>>
    export type UpdateSocieteMutationBody = UpdateSocieteRequest
    export type UpdateSocieteMutationError = unknown

    /**
 * @summary Update societe
 */
export const useUpdateSociete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSociete>>, TError,{id: number;data: UpdateSocieteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateSociete>>,
        TError,
        {id: number;data: UpdateSocieteRequest},
        TContext
      > => {

      const mutationOptions = getUpdateSocieteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete company (ADMIN or COMPTABLE if assigned)
 * @summary Delete societe
 */
export const deleteSociete = (
    id: MaybeRef<number>,
 ) => {
      id = unref(id);
      
      return customAxios<void>(
      {url: `/api/societes/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSocieteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSociete>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSociete>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteSociete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSociete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteSociete(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSocieteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSociete>>>
    
    export type DeleteSocieteMutationError = unknown

    /**
 * @summary Delete societe
 */
export const useDeleteSociete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSociete>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof deleteSociete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteSocieteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Change current user password
 * @summary Change password
 */
export const changePassword = (
    changePasswordRequest: MaybeRef<ChangePasswordRequest>,
 ) => {
      changePasswordRequest = unref(changePasswordRequest);
      
      return customAxios<void>(
      {url: `/api/auth/password`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: changePasswordRequest
    },
      );
    }
  


export const getChangePasswordMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordRequest}, TContext> => {

const mutationKey = ['changePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePassword>>, {data: ChangePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  changePassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof changePassword>>>
    export type ChangePasswordMutationBody = ChangePasswordRequest
    export type ChangePasswordMutationError = unknown

    /**
 * @summary Change password
 */
export const useChangePassword = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePassword>>, TError,{data: ChangePasswordRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof changePassword>>,
        TError,
        {data: ChangePasswordRequest},
        TContext
      > => {

      const mutationOptions = getChangePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get current authenticated user information
 * @summary Get current user
 */
export const getCurrentUser = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<Users>(
      {url: `/api/auth/me`, method: 'GET', signal
    },
      );
    }
  



export const getGetCurrentUserQueryKey = () => {
    return [
    'api','auth','me'
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> 
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = unknown


/**
 * @summary Get current user
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Update current user profile
 * @summary Update current user
 */
export const updateCurrentUser = (
    updateUserRequest: MaybeRef<UpdateUserRequest>,
 ) => {
      updateUserRequest = unref(updateUserRequest);
      
      return customAxios<Users>(
      {url: `/api/auth/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserRequest
    },
      );
    }
  


export const getUpdateCurrentUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateCurrentUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUser>>, {data: UpdateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUser>>>
    export type UpdateCurrentUserMutationBody = UpdateUserRequest
    export type UpdateCurrentUserMutationError = unknown

    /**
 * @summary Update current user
 */
export const useUpdateCurrentUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUser>>, TError,{data: UpdateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof updateCurrentUser>>,
        TError,
        {data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get all roles for a user (ADMIN or COMPTABLE)
 * @summary Get user roles
 */
export const getUserRoles = (
    id: MaybeRef<number>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customAxios<string[]>(
      {url: `/api/users/${id}/roles`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserRolesQueryKey = (id?: MaybeRef<number>,) => {
    return [
    'api','users',id,'roles'
    ] as const;
    }

    
export const getGetUserRolesQueryOptions = <TData = Awaited<ReturnType<typeof getUserRoles>>, TError = unknown>(id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetUserRolesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRoles>>> = ({ signal }) => getUserRoles(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData> 
}

export type GetUserRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserRoles>>>
export type GetUserRolesQueryError = unknown


/**
 * @summary Get user roles
 */

export function useGetUserRoles<TData = Awaited<ReturnType<typeof getUserRoles>>, TError = unknown>(
 id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserRolesQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Assign a role to user (ADMIN only)
 * @summary Assign role to user
 */
export const assignRole = (
    id: MaybeRef<number>,
    assignRoleRequest: MaybeRef<AssignRoleRequest>,
 signal?: AbortSignal
) => {
      id = unref(id);
assignRoleRequest = unref(assignRoleRequest);
      
      return customAxios<void>(
      {url: `/api/users/${id}/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assignRoleRequest, signal
    },
      );
    }
  


export const getAssignRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRole>>, TError,{id: number;data: AssignRoleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignRole>>, TError,{id: number;data: AssignRoleRequest}, TContext> => {

const mutationKey = ['assignRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignRole>>, {id: number;data: AssignRoleRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  assignRole(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignRoleMutationResult = NonNullable<Awaited<ReturnType<typeof assignRole>>>
    export type AssignRoleMutationBody = AssignRoleRequest
    export type AssignRoleMutationError = unknown

    /**
 * @summary Assign role to user
 */
export const useAssignRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignRole>>, TError,{id: number;data: AssignRoleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof assignRole>>,
        TError,
        {id: number;data: AssignRoleRequest},
        TContext
      > => {

      const mutationOptions = getAssignRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new societe user (ADMIN or COMPTABLE)
 * @summary Create societe user
 */
export const createSocieteUser = (
    createUserRequest: MaybeRef<CreateUserRequest>,
 signal?: AbortSignal
) => {
      createUserRequest = unref(createUserRequest);
      
      return customAxios<Users>(
      {url: `/api/users/societe`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserRequest, signal
    },
      );
    }
  


export const getCreateSocieteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSocieteUser>>, TError,{data: CreateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSocieteUser>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createSocieteUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSocieteUser>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSocieteUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSocieteUserMutationResult = NonNullable<Awaited<ReturnType<typeof createSocieteUser>>>
    export type CreateSocieteUserMutationBody = CreateUserRequest
    export type CreateSocieteUserMutationError = unknown

    /**
 * @summary Create societe user
 */
export const useCreateSocieteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSocieteUser>>, TError,{data: CreateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createSocieteUser>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateSocieteUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new employee user (ADMIN, COMPTABLE, or SOCIETE)
 * @summary Create employee user
 */
export const createEmployeeUser = (
    createUserRequest: MaybeRef<CreateUserRequest>,
 signal?: AbortSignal
) => {
      createUserRequest = unref(createUserRequest);
      
      return customAxios<Users>(
      {url: `/api/users/employee`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserRequest, signal
    },
      );
    }
  


export const getCreateEmployeeUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEmployeeUser>>, TError,{data: CreateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEmployeeUser>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createEmployeeUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEmployeeUser>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createEmployeeUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEmployeeUserMutationResult = NonNullable<Awaited<ReturnType<typeof createEmployeeUser>>>
    export type CreateEmployeeUserMutationBody = CreateUserRequest
    export type CreateEmployeeUserMutationError = unknown

    /**
 * @summary Create employee user
 */
export const useCreateEmployeeUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEmployeeUser>>, TError,{data: CreateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createEmployeeUser>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateEmployeeUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new comptable user (ADMIN only)
 * @summary Create comptable
 */
export const createComptable = (
    createUserRequest: MaybeRef<CreateUserRequest>,
 signal?: AbortSignal
) => {
      createUserRequest = unref(createUserRequest);
      
      return customAxios<Users>(
      {url: `/api/users/comptable`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserRequest, signal
    },
      );
    }
  


export const getCreateComptableMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComptable>>, TError,{data: CreateUserRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createComptable>>, TError,{data: CreateUserRequest}, TContext> => {

const mutationKey = ['createComptable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComptable>>, {data: CreateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  createComptable(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateComptableMutationResult = NonNullable<Awaited<ReturnType<typeof createComptable>>>
    export type CreateComptableMutationBody = CreateUserRequest
    export type CreateComptableMutationError = unknown

    /**
 * @summary Create comptable
 */
export const useCreateComptable = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComptable>>, TError,{data: CreateUserRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createComptable>>,
        TError,
        {data: CreateUserRequest},
        TContext
      > => {

      const mutationOptions = getCreateComptableMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get list of all companies (ADMIN or COMPTABLE)
 * @summary Get all societes
 */
export const getAllSocietes = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<Societes[]>(
      {url: `/api/societes`, method: 'GET', signal
    },
      );
    }
  



export const getGetAllSocietesQueryKey = () => {
    return [
    'api','societes'
    ] as const;
    }

    
export const getGetAllSocietesQueryOptions = <TData = Awaited<ReturnType<typeof getAllSocietes>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSocietes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetAllSocietesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllSocietes>>> = ({ signal }) => getAllSocietes(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllSocietes>>, TError, TData> 
}

export type GetAllSocietesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllSocietes>>>
export type GetAllSocietesQueryError = unknown


/**
 * @summary Get all societes
 */

export function useGetAllSocietes<TData = Awaited<ReturnType<typeof getAllSocietes>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllSocietes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllSocietesQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Create a new societe (ADMIN or COMPTABLE)
 * @summary Create societe
 */
export const createSociete = (
    createSocieteRequest: MaybeRef<CreateSocieteRequest>,
 signal?: AbortSignal
) => {
      createSocieteRequest = unref(createSocieteRequest);
      
      return customAxios<Societes>(
      {url: `/api/societes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSocieteRequest, signal
    },
      );
    }
  


export const getCreateSocieteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSociete>>, TError,{data: CreateSocieteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSociete>>, TError,{data: CreateSocieteRequest}, TContext> => {

const mutationKey = ['createSociete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSociete>>, {data: CreateSocieteRequest}> = (props) => {
          const {data} = props ?? {};

          return  createSociete(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSocieteMutationResult = NonNullable<Awaited<ReturnType<typeof createSociete>>>
    export type CreateSocieteMutationBody = CreateSocieteRequest
    export type CreateSocieteMutationError = unknown

    /**
 * @summary Create societe
 */
export const useCreateSociete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSociete>>, TError,{data: CreateSocieteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createSociete>>,
        TError,
        {data: CreateSocieteRequest},
        TContext
      > => {

      const mutationOptions = getCreateSocieteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create user-societe association (ADMIN or COMPTABLE)
 * @summary Assign user to societe
 */
export const assignUserToSociete = (
    userSocieteRequest: MaybeRef<UserSocieteRequest>,
 signal?: AbortSignal
) => {
      userSocieteRequest = unref(userSocieteRequest);
      
      return customAxios<void>(
      {url: `/api/societes/user-assignment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userSocieteRequest, signal
    },
      );
    }
  


export const getAssignUserToSocieteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignUserToSociete>>, TError,{data: UserSocieteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignUserToSociete>>, TError,{data: UserSocieteRequest}, TContext> => {

const mutationKey = ['assignUserToSociete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignUserToSociete>>, {data: UserSocieteRequest}> = (props) => {
          const {data} = props ?? {};

          return  assignUserToSociete(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignUserToSocieteMutationResult = NonNullable<Awaited<ReturnType<typeof assignUserToSociete>>>
    export type AssignUserToSocieteMutationBody = UserSocieteRequest
    export type AssignUserToSocieteMutationError = unknown

    /**
 * @summary Assign user to societe
 */
export const useAssignUserToSociete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignUserToSociete>>, TError,{data: UserSocieteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof assignUserToSociete>>,
        TError,
        {data: UserSocieteRequest},
        TContext
      > => {

      const mutationOptions = getAssignUserToSocieteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create comptable-societe association (ADMIN only)
 * @summary Assign comptable to societe
 */
export const assignComptable = (
    comptableSocieteRequest: MaybeRef<ComptableSocieteRequest>,
 signal?: AbortSignal
) => {
      comptableSocieteRequest = unref(comptableSocieteRequest);
      
      return customAxios<void>(
      {url: `/api/societes/comptable-assignment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: comptableSocieteRequest, signal
    },
      );
    }
  


export const getAssignComptableMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignComptable>>, TError,{data: ComptableSocieteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof assignComptable>>, TError,{data: ComptableSocieteRequest}, TContext> => {

const mutationKey = ['assignComptable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof assignComptable>>, {data: ComptableSocieteRequest}> = (props) => {
          const {data} = props ?? {};

          return  assignComptable(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AssignComptableMutationResult = NonNullable<Awaited<ReturnType<typeof assignComptable>>>
    export type AssignComptableMutationBody = ComptableSocieteRequest
    export type AssignComptableMutationError = unknown

    /**
 * @summary Assign comptable to societe
 */
export const useAssignComptable = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof assignComptable>>, TError,{data: ComptableSocieteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof assignComptable>>,
        TError,
        {data: ComptableSocieteRequest},
        TContext
      > => {

      const mutationOptions = getAssignComptableMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create employee association (ADMIN, COMPTABLE, or SOCIETE)
 * @summary Link employee to societe
 */
export const createEmployee = (
    createEmployeeRequest: MaybeRef<CreateEmployeeRequest>,
 signal?: AbortSignal
) => {
      createEmployeeRequest = unref(createEmployeeRequest);
      
      return customAxios<void>(
      {url: `/api/employees`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createEmployeeRequest, signal
    },
      );
    }
  


export const getCreateEmployeeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEmployee>>, TError,{data: CreateEmployeeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createEmployee>>, TError,{data: CreateEmployeeRequest}, TContext> => {

const mutationKey = ['createEmployee'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createEmployee>>, {data: CreateEmployeeRequest}> = (props) => {
          const {data} = props ?? {};

          return  createEmployee(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateEmployeeMutationResult = NonNullable<Awaited<ReturnType<typeof createEmployee>>>
    export type CreateEmployeeMutationBody = CreateEmployeeRequest
    export type CreateEmployeeMutationError = unknown

    /**
 * @summary Link employee to societe
 */
export const useCreateEmployee = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createEmployee>>, TError,{data: CreateEmployeeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createEmployee>>,
        TError,
        {data: CreateEmployeeRequest},
        TContext
      > => {

      const mutationOptions = getCreateEmployeeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get new access token using refresh token
 * @summary Refresh token
 */
export const refreshToken = (
    params: MaybeRef<RefreshTokenParams>,
 signal?: AbortSignal
) => {
      params = unref(params);
      
      return customAxios<AuthResponse>(
      {url: `/api/auth/refresh`, method: 'POST',
        params: unref(params), signal
    },
      );
    }
  


export const getRefreshTokenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{params: RefreshTokenParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{params: RefreshTokenParams}, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, {params: RefreshTokenParams}> = (props) => {
          const {params} = props ?? {};

          return  refreshToken(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    
    export type RefreshTokenMutationError = unknown

    /**
 * @summary Refresh token
 */
export const useRefreshToken = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{params: RefreshTokenParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        {params: RefreshTokenParams},
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Logout user and invalidate refresh token
 * @summary Logout
 */
export const logout = (
    params?: MaybeRef<LogoutParams>,
 signal?: AbortSignal
) => {
      params = unref(params);
      
      return customAxios<void>(
      {url: `/api/auth/logout`, method: 'POST',
        params: unref(params), signal
    },
      );
    }
  


export const getLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{params?: LogoutParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{params?: LogoutParams}, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, {params?: LogoutParams}> = (props) => {
          const {params} = props ?? {};

          return  logout(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = unknown

    /**
 * @summary Logout
 */
export const useLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,{params?: LogoutParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof logout>>,
        TError,
        {params?: LogoutParams},
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Authenticate user and return JWT tokens
 * @summary Login
 */
export const login = (
    loginRequest: MaybeRef<LoginRequest>,
 signal?: AbortSignal
) => {
      loginRequest = unref(loginRequest);
      
      return customAxios<AuthResponse>(
      {url: `/api/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      );
    }
  


export const getLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = unknown

    /**
 * @summary Login
 */
export const useLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get list of all users (ADMIN or COMPTABLE)
 * @summary Get all users
 */
export const getAllUsers = (
    
 signal?: AbortSignal
) => {
      
      
      return customAxios<UserResponse[]>(
      {url: `/api/users`, method: 'GET', signal
    },
      );
    }
  



export const getGetAllUsersQueryKey = () => {
    return [
    'api','users'
    ] as const;
    }

    
export const getGetAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({ signal }) => getAllUsers(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData> 
}

export type GetAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getAllUsers>>>
export type GetAllUsersQueryError = unknown


/**
 * @summary Get all users
 */

export function useGetAllUsers<TData = Awaited<ReturnType<typeof getAllUsers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get all users associated with a company
 * @summary Get societe users
 */
export const getSocieteUsers = (
    id: MaybeRef<number>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customAxios<UserResponse[]>(
      {url: `/api/societes/${id}/users`, method: 'GET', signal
    },
      );
    }
  



export const getGetSocieteUsersQueryKey = (id?: MaybeRef<number>,) => {
    return [
    'api','societes',id,'users'
    ] as const;
    }

    
export const getGetSocieteUsersQueryOptions = <TData = Awaited<ReturnType<typeof getSocieteUsers>>, TError = unknown>(id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteUsers>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetSocieteUsersQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSocieteUsers>>> = ({ signal }) => getSocieteUsers(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSocieteUsers>>, TError, TData> 
}

export type GetSocieteUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getSocieteUsers>>>
export type GetSocieteUsersQueryError = unknown


/**
 * @summary Get societe users
 */

export function useGetSocieteUsers<TData = Awaited<ReturnType<typeof getSocieteUsers>>, TError = unknown>(
 id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteUsers>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSocieteUsersQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get all employees of a company
 * @summary Get societe employees
 */
export const getSocieteEmployees = (
    id: MaybeRef<number>,
 signal?: AbortSignal
) => {
      id = unref(id);
      
      return customAxios<Employees[]>(
      {url: `/api/societes/${id}/employees`, method: 'GET', signal
    },
      );
    }
  



export const getGetSocieteEmployeesQueryKey = (id?: MaybeRef<number>,) => {
    return [
    'api','societes',id,'employees'
    ] as const;
    }

    
export const getGetSocieteEmployeesQueryOptions = <TData = Awaited<ReturnType<typeof getSocieteEmployees>>, TError = unknown>(id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteEmployees>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetSocieteEmployeesQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSocieteEmployees>>> = ({ signal }) => getSocieteEmployees(id, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(id))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSocieteEmployees>>, TError, TData> 
}

export type GetSocieteEmployeesQueryResult = NonNullable<Awaited<ReturnType<typeof getSocieteEmployees>>>
export type GetSocieteEmployeesQueryError = unknown


/**
 * @summary Get societe employees
 */

export function useGetSocieteEmployees<TData = Awaited<ReturnType<typeof getSocieteEmployees>>, TError = unknown>(
 id: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSocieteEmployees>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSocieteEmployeesQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get all companies for a user
 * @summary Get user societes
 */
export const getUserSocietes = (
    userId: MaybeRef<number>,
 signal?: AbortSignal
) => {
      userId = unref(userId);
      
      return customAxios<Societes[]>(
      {url: `/api/societes/user/${userId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUserSocietesQueryKey = (userId?: MaybeRef<number>,) => {
    return [
    'api','societes','user',userId
    ] as const;
    }

    
export const getGetUserSocietesQueryOptions = <TData = Awaited<ReturnType<typeof getUserSocietes>>, TError = unknown>(userId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSocietes>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetUserSocietesQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserSocietes>>> = ({ signal }) => getUserSocietes(userId, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(userId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserSocietes>>, TError, TData> 
}

export type GetUserSocietesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserSocietes>>>
export type GetUserSocietesQueryError = unknown


/**
 * @summary Get user societes
 */

export function useGetUserSocietes<TData = Awaited<ReturnType<typeof getUserSocietes>>, TError = unknown>(
 userId: MaybeRef<number>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSocietes>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserSocietesQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get all authentication logs (ADMIN only)
 * @summary Get all auth logs
 */
export const getAllLogs = (
    params?: MaybeRef<GetAllLogsParams>,
 signal?: AbortSignal
) => {
      params = unref(params);
      
      return customAxios<AuthLogResponse[]>(
      {url: `/api/auth/logs`, method: 'GET',
        params: unref(params), signal
    },
      );
    }
  



export const getGetAllLogsQueryKey = (params?: MaybeRef<GetAllLogsParams>,) => {
    return [
    'api','auth','logs', ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllLogsQueryOptions = <TData = Awaited<ReturnType<typeof getAllLogs>>, TError = unknown>(params?: MaybeRef<GetAllLogsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetAllLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllLogs>>> = ({ signal }) => getAllLogs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllLogs>>, TError, TData> 
}

export type GetAllLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllLogs>>>
export type GetAllLogsQueryError = unknown


/**
 * @summary Get all auth logs
 */

export function useGetAllLogs<TData = Awaited<ReturnType<typeof getAllLogs>>, TError = unknown>(
 params?: MaybeRef<GetAllLogsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllLogs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllLogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get authentication logs for a specific user
 * @summary Get user auth logs
 */
export const getUserLogs = (
    userId: MaybeRef<number>,
    params?: MaybeRef<GetUserLogsParams>,
 signal?: AbortSignal
) => {
      userId = unref(userId);
params = unref(params);
      
      return customAxios<AuthLogResponse[]>(
      {url: `/api/auth/logs/user/${userId}`, method: 'GET',
        params: unref(params), signal
    },
      );
    }
  



export const getGetUserLogsQueryKey = (userId?: MaybeRef<number>,
    params?: MaybeRef<GetUserLogsParams>,) => {
    return [
    'api','auth','logs','user',userId, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetUserLogsQueryOptions = <TData = Awaited<ReturnType<typeof getUserLogs>>, TError = unknown>(userId: MaybeRef<number>,
    params?: MaybeRef<GetUserLogsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetUserLogsQueryKey(userId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserLogs>>> = ({ signal }) => getUserLogs(userId,params, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(userId))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserLogs>>, TError, TData> 
}

export type GetUserLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserLogs>>>
export type GetUserLogsQueryError = unknown


/**
 * @summary Get user auth logs
 */

export function useGetUserLogs<TData = Awaited<ReturnType<typeof getUserLogs>>, TError = unknown>(
 userId: MaybeRef<number>,
    params?: MaybeRef<GetUserLogsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserLogs>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserLogsQueryOptions(userId,params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Get authentication logs filtered by action type (ADMIN only)
 * @summary Get logs by action
 */
export const getLogsByAction = (
    action: MaybeRef<string>,
    params?: MaybeRef<GetLogsByActionParams>,
 signal?: AbortSignal
) => {
      action = unref(action);
params = unref(params);
      
      return customAxios<AuthLogResponse[]>(
      {url: `/api/auth/logs/action/${action}`, method: 'GET',
        params: unref(params), signal
    },
      );
    }
  



export const getGetLogsByActionQueryKey = (action?: MaybeRef<string>,
    params?: MaybeRef<GetLogsByActionParams>,) => {
    return [
    'api','auth','logs','action',action, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetLogsByActionQueryOptions = <TData = Awaited<ReturnType<typeof getLogsByAction>>, TError = unknown>(action: MaybeRef<string>,
    params?: MaybeRef<GetLogsByActionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsByAction>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  getGetLogsByActionQueryKey(action,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogsByAction>>> = ({ signal }) => getLogsByAction(action,params, signal);

      

      

   return  { queryKey, queryFn, enabled: computed(() => !!(unref(action))), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLogsByAction>>, TError, TData> 
}

export type GetLogsByActionQueryResult = NonNullable<Awaited<ReturnType<typeof getLogsByAction>>>
export type GetLogsByActionQueryError = unknown


/**
 * @summary Get logs by action
 */

export function useGetLogsByAction<TData = Awaited<ReturnType<typeof getLogsByAction>>, TError = unknown>(
 action: MaybeRef<string>,
    params?: MaybeRef<GetLogsByActionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsByAction>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLogsByActionQueryOptions(action,params,options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}





/**
 * Remove a role from user (ADMIN only)
 * @summary Remove role from user
 */
export const removeRole = (
    id: MaybeRef<number>,
    roleId: MaybeRef<number>,
 ) => {
      id = unref(id);
roleId = unref(roleId);
      
      return customAxios<void>(
      {url: `/api/users/${id}/roles/${roleId}`, method: 'DELETE'
    },
      );
    }
  


export const getRemoveRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{id: number;roleId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{id: number;roleId: number}, TContext> => {

const mutationKey = ['removeRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRole>>, {id: number;roleId: number}> = (props) => {
          const {id,roleId} = props ?? {};

          return  removeRole(id,roleId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeRole>>>
    
    export type RemoveRoleMutationError = unknown

    /**
 * @summary Remove role from user
 */
export const useRemoveRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{id: number;roleId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof removeRole>>,
        TError,
        {id: number;roleId: number},
        TContext
      > => {

      const mutationOptions = getRemoveRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove user-societe association
 * @summary Remove user from societe
 */
export const removeUserFromSociete = (
    userId: MaybeRef<number>,
    societeId: MaybeRef<number>,
 ) => {
      userId = unref(userId);
societeId = unref(societeId);
      
      return customAxios<void>(
      {url: `/api/societes/user-assignment/${userId}/${societeId}`, method: 'DELETE'
    },
      );
    }
  


export const getRemoveUserFromSocieteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserFromSociete>>, TError,{userId: number;societeId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeUserFromSociete>>, TError,{userId: number;societeId: number}, TContext> => {

const mutationKey = ['removeUserFromSociete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUserFromSociete>>, {userId: number;societeId: number}> = (props) => {
          const {userId,societeId} = props ?? {};

          return  removeUserFromSociete(userId,societeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserFromSocieteMutationResult = NonNullable<Awaited<ReturnType<typeof removeUserFromSociete>>>
    
    export type RemoveUserFromSocieteMutationError = unknown

    /**
 * @summary Remove user from societe
 */
export const useRemoveUserFromSociete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUserFromSociete>>, TError,{userId: number;societeId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof removeUserFromSociete>>,
        TError,
        {userId: number;societeId: number},
        TContext
      > => {

      const mutationOptions = getRemoveUserFromSocieteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove comptable-societe association (ADMIN only)
 * @summary Remove comptable from societe
 */
export const removeComptable = (
    userId: MaybeRef<number>,
    societeId: MaybeRef<number>,
 ) => {
      userId = unref(userId);
societeId = unref(societeId);
      
      return customAxios<void>(
      {url: `/api/societes/comptable-assignment/${userId}/${societeId}`, method: 'DELETE'
    },
      );
    }
  


export const getRemoveComptableMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeComptable>>, TError,{userId: number;societeId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeComptable>>, TError,{userId: number;societeId: number}, TContext> => {

const mutationKey = ['removeComptable'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeComptable>>, {userId: number;societeId: number}> = (props) => {
          const {userId,societeId} = props ?? {};

          return  removeComptable(userId,societeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveComptableMutationResult = NonNullable<Awaited<ReturnType<typeof removeComptable>>>
    
    export type RemoveComptableMutationError = unknown

    /**
 * @summary Remove comptable from societe
 */
export const useRemoveComptable = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeComptable>>, TError,{userId: number;societeId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof removeComptable>>,
        TError,
        {userId: number;societeId: number},
        TContext
      > => {

      const mutationOptions = getRemoveComptableMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
