/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Document Service API
 * Service de gestion des documents - Upload, versioning, partage et m√©tadonn√©es. Toutes les requ√™tes passent via la Gateway.
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { computed, unref } from "vue";
import type { MaybeRef } from "vue";

import { customInstance } from "../../../api/axios-instance";
import type { ErrorType, BodyType } from "../../../api/axios-instance";
/**
 * Request for updating a document
 */
export interface DocumentUpdateRequest {
  /**
   * Document title
   * @minLength 0
   * @maxLength 255
   */
  title?: string;
  /**
   * Document description
   * @minLength 0
   * @maxLength 2000
   */
  description?: string;
  /** Category ID */
  categoryId?: number;
  /** Make document public */
  isPublic?: boolean;
  /** Tags to associate with the document */
  tags?: string[];
}

/**
 * Custom metadata
 */
export type DocumentResponseMetadata = { [key: string]: string };

/**
 * Document response
 */
export interface DocumentResponse {
  /** Document ID */
  id?: number;
  /** Document title */
  title?: string;
  /** Document description */
  description?: string;
  /** Original file name */
  fileName?: string;
  /** File size in bytes */
  fileSize?: number;
  /** MIME type */
  mimeType?: string;
  /** Category ID */
  categoryId?: number;
  /** Category name */
  categoryName?: string;
  /** Uploaded by user ID */
  uploadedBy?: string;
  /** Is document public */
  isPublic?: boolean;
  /** Current version number */
  version?: number;
  /** File checksum (SHA-256) */
  checksum?: string;
  /** Associated tags */
  tags?: TagResponse[];
  /** Custom metadata */
  metadata?: DocumentResponseMetadata;
  /** Download URL (presigned) */
  downloadUrl?: string;
  /** Creation timestamp */
  createdAt?: string;
  /** Last update timestamp */
  updatedAt?: string;
}

/**
 * Tag response
 */
export interface TagResponse {
  /** Tag ID */
  id?: number;
  /** Tag name */
  name?: string;
  /** Creation timestamp */
  createdAt?: string;
}

/**
 * Key-value pairs of metadata
 */
export type MetadataRequestMetadata = { [key: string]: string };

/**
 * Request for setting document metadata
 */
export interface MetadataRequest {
  /** Key-value pairs of metadata */
  metadata: MetadataRequestMetadata;
}

/**
 * Permission level
 * @pattern ^(READ|WRITE)$
 */
export type DocumentShareRequestPermission =
  (typeof DocumentShareRequestPermission)[keyof typeof DocumentShareRequestPermission];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DocumentShareRequestPermission = {
  READ: "READ",
  WRITE: "WRITE",
} as const;

/**
 * Request for sharing a document
 */
export interface DocumentShareRequest {
  /**
   * User ID to share with
   * @minLength 0
   * @maxLength 100
   */
  sharedWith: string;
  /**
   * Permission level
   * @pattern ^(READ|WRITE)$
   */
  permission?: DocumentShareRequestPermission;
  /** Expiration date (null for no expiration) */
  expiresAt?: string;
}

/**
 * Document share response
 */
export interface DocumentShareResponse {
  /** Share ID */
  id?: number;
  /** Document ID */
  documentId?: number;
  /** Document title */
  documentTitle?: string;
  /** Shared with user ID */
  sharedWith?: string;
  /** Permission level */
  permission?: string;
  /** Expiration date */
  expiresAt?: string;
  /** Is share still active */
  isActive?: boolean;
  /** Created by user ID */
  createdBy?: string;
  /** Creation timestamp */
  createdAt?: string;
}

/**
 * Request for creating or updating a category
 */
export interface CategoryRequest {
  /**
   * Category name
   * @minLength 0
   * @maxLength 100
   */
  name: string;
  /**
   * Category description
   * @minLength 0
   * @maxLength 500
   */
  description?: string;
  /** Parent category ID for hierarchical structure */
  parentCategoryId?: number;
}

/**
 * Category response
 */
export interface CategoryResponse {
  /** Category ID */
  id?: number;
  /** Category name */
  name?: string;
  /** Category description */
  description?: string;
  /** Parent category ID */
  parentCategoryId?: number;
  /** Parent category name */
  parentCategoryName?: string;
  /** Sub-categories */
  children?: unknown[];
  /** Creation timestamp */
  createdAt?: string;
  /** Last update timestamp */
  updatedAt?: string;
}

/**
 * Request for creating a tag
 */
export interface TagRequest {
  /**
   * Tag name
   * @minLength 0
   * @maxLength 50
   */
  name: string;
}

/**
 * Document metadata
 */
export interface DocumentUploadRequest {
  /**
   * Document title
   * @minLength 0
   * @maxLength 255
   */
  title: string;
  /**
   * Document description
   * @minLength 0
   * @maxLength 2000
   */
  description?: string;
  /** Category ID */
  categoryId?: number;
  /** Make document public */
  isPublic?: boolean;
  /** Tags to associate with the document */
  tags?: string[];
}

/**
 * Version metadata
 */
export interface DocumentVersionUploadRequest {
  /**
   * Description of changes in this version
   * @minLength 0
   * @maxLength 500
   */
  changeDescription?: string;
}

/**
 * Document version response
 */
export interface DocumentVersionResponse {
  /** Version ID */
  id?: number;
  /** Document ID */
  documentId?: number;
  /** Version number */
  versionNumber?: number;
  /** File name */
  fileName?: string;
  /** File size in bytes */
  fileSize?: number;
  /** Uploaded by user ID */
  uploadedBy?: string;
  /** Description of changes */
  changeDescription?: string;
  /** File checksum (SHA-256) */
  checksum?: string;
  /** Download URL (presigned) */
  downloadUrl?: string;
  /** Creation timestamp */
  createdAt?: string;
}

/**
 * Search criteria for documents
 */
export interface DocumentSearchRequest {
  /** Search query (searches in title, description, file name) */
  query?: string;
  /** Filter by category ID */
  categoryId?: number;
  /** Filter by uploader user ID */
  uploadedBy?: string;
  /** Filter by tag name */
  tag?: string;
}

export type GetMetadata200 = { [key: string]: string };

export type GetMetadata404 = { [key: string]: string };

export type SetMetadata200 = { [key: string]: string };

export type SetMetadata404 = { [key: string]: string };

export type GetAllParams = {
  /**
   * Search query
   */
  search?: string;
};

export type UploadBody = {
  /** File to upload */
  file: Blob;
  data: DocumentUploadRequest;
};

export type UploadVersionBody = {
  /** New file version */
  file: Blob;
  data?: DocumentVersionUploadRequest;
};

export type SearchGetParams = {
  /**
   * Search query
   */
  query?: string;
  /**
   * Category ID
   */
  categoryId?: number;
  /**
   * Uploader user ID
   */
  uploadedBy?: string;
  /**
   * Tag name
   */
  tag?: string;
};

/**
 * Category response
 */
export type GetAll2200Item = {
  /** Category ID */
  id?: number;
  /** Category name */
  name?: string;
  /** Category description */
  description?: string;
  /** Parent category ID */
  parentCategoryId?: number;
  /** Parent category name */
  parentCategoryName?: string;
  /** Sub-categories */
  children?: unknown[];
  /** Creation timestamp */
  createdAt?: string;
  /** Last update timestamp */
  updatedAt?: string;
};

export type GetDownloadUrl200 = { [key: string]: string };

export type GetDownloadUrl404 = { [key: string]: string };

export type GetVersionDownloadUrl200 = { [key: string]: string };

export type GetVersionDownloadUrl404 = { [key: string]: string };

/**
 * Category response
 */
export type GetTree200Item = {
  /** Category ID */
  id?: number;
  /** Category name */
  name?: string;
  /** Category description */
  description?: string;
  /** Parent category ID */
  parentCategoryId?: number;
  /** Parent category name */
  parentCategoryName?: string;
  /** Sub-categories */
  children?: unknown[];
  /** Creation timestamp */
  createdAt?: string;
  /** Last update timestamp */
  updatedAt?: string;
};

/**
 * Category response
 */
export type GetRootCategories200Item = {
  /** Category ID */
  id?: number;
  /** Category name */
  name?: string;
  /** Category description */
  description?: string;
  /** Parent category ID */
  parentCategoryId?: number;
  /** Parent category name */
  parentCategoryName?: string;
  /** Sub-categories */
  children?: unknown[];
  /** Creation timestamp */
  createdAt?: string;
  /** Last update timestamp */
  updatedAt?: string;
};

/**
 * Returns document details including tags and metadata
 * @summary Get document by ID
 */
export const getById = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<DocumentResponse>({
    url: `/api/documents/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetByIdQueryKey = (id?: MaybeRef<number>) => {
  return ["api", "documents", id] as const;
};

export const getGetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<DocumentResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById>>> = ({
    signal,
  }) => getById(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>;
};

export type GetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getById>>
>;
export type GetByIdQueryError = ErrorType<DocumentResponse>;

/**
 * @summary Get document by ID
 */

export function useGetById<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<DocumentResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Updates document metadata (not the file)
 * @summary Update document metadata
 */
export const update = (
  id: MaybeRef<number>,
  documentUpdateRequest: MaybeRef<DocumentUpdateRequest>,
) => {
  id = unref(id);
  documentUpdateRequest = unref(documentUpdateRequest);

  return customInstance<DocumentResponse>({
    url: `/api/documents/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: documentUpdateRequest,
  });
};

export const getUpdateMutationOptions = <
  TError = ErrorType<DocumentResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update>>,
    TError,
    { id: number; data: BodyType<DocumentUpdateRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof update>>,
  TError,
  { id: number; data: BodyType<DocumentUpdateRequest> },
  TContext
> => {
  const mutationKey = ["update"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof update>>,
    { id: number; data: BodyType<DocumentUpdateRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return update(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof update>>
>;
export type UpdateMutationBody = BodyType<DocumentUpdateRequest>;
export type UpdateMutationError = ErrorType<DocumentResponse>;

/**
 * @summary Update document metadata
 */
export const useUpdate = <
  TError = ErrorType<DocumentResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof update>>,
      TError,
      { id: number; data: BodyType<DocumentUpdateRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof update>>,
  TError,
  { id: number; data: BodyType<DocumentUpdateRequest> },
  TContext
> => {
  const mutationOptions = getUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a document and its file from storage
 * @summary Delete a document
 */
export const _delete = (id: MaybeRef<number>) => {
  id = unref(id);

  return customInstance<void>({
    url: `/api/documents/${id}`,
    method: "DELETE",
  });
};

export const getDeleteMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof _delete>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof _delete>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["_delete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof _delete>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return _delete(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type _DeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof _delete>>
>;

export type _DeleteMutationError = ErrorType<void>;

/**
 * @summary Delete a document
 */
export const useDelete = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof _delete>>,
      TError,
      { id: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof _delete>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns custom metadata for a document
 * @summary Get document metadata
 */
export const getMetadata = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<GetMetadata200>({
    url: `/api/documents/${id}/metadata`,
    method: "GET",
    signal,
  });
};

export const getGetMetadataQueryKey = (id?: MaybeRef<number>) => {
  return ["api", "documents", id, "metadata"] as const;
};

export const getGetMetadataQueryOptions = <
  TData = Awaited<ReturnType<typeof getMetadata>>,
  TError = ErrorType<GetMetadata404>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetMetadataQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadata>>> = ({
    signal,
  }) => getMetadata(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>;
};

export type GetMetadataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMetadata>>
>;
export type GetMetadataQueryError = ErrorType<GetMetadata404>;

/**
 * @summary Get document metadata
 */

export function useGetMetadata<
  TData = Awaited<ReturnType<typeof getMetadata>>,
  TError = ErrorType<GetMetadata404>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMetadataQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Sets custom metadata key-value pairs
 * @summary Set document metadata
 */
export const setMetadata = (
  id: MaybeRef<number>,
  metadataRequest: MaybeRef<MetadataRequest>,
) => {
  id = unref(id);
  metadataRequest = unref(metadataRequest);

  return customInstance<SetMetadata200>({
    url: `/api/documents/${id}/metadata`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: metadataRequest,
  });
};

export const getSetMetadataMutationOptions = <
  TError = ErrorType<SetMetadata404>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setMetadata>>,
    TError,
    { id: number; data: BodyType<MetadataRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setMetadata>>,
  TError,
  { id: number; data: BodyType<MetadataRequest> },
  TContext
> => {
  const mutationKey = ["setMetadata"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setMetadata>>,
    { id: number; data: BodyType<MetadataRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return setMetadata(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetMetadataMutationResult = NonNullable<
  Awaited<ReturnType<typeof setMetadata>>
>;
export type SetMetadataMutationBody = BodyType<MetadataRequest>;
export type SetMetadataMutationError = ErrorType<SetMetadata404>;

/**
 * @summary Set document metadata
 */
export const useSetMetadata = <
  TError = ErrorType<SetMetadata404>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setMetadata>>,
      TError,
      { id: number; data: BodyType<MetadataRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof setMetadata>>,
  TError,
  { id: number; data: BodyType<MetadataRequest> },
  TContext
> => {
  const mutationOptions = getSetMetadataMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Updates share permission or expiration
 * @summary Update a share
 */
export const update1 = (
  shareId: MaybeRef<number>,
  documentShareRequest: MaybeRef<DocumentShareRequest>,
) => {
  shareId = unref(shareId);
  documentShareRequest = unref(documentShareRequest);

  return customInstance<DocumentShareResponse>({
    url: `/api/documents/shares/${shareId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: documentShareRequest,
  });
};

export const getUpdate1MutationOptions = <
  TError = ErrorType<DocumentShareResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update1>>,
    TError,
    { shareId: number; data: BodyType<DocumentShareRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof update1>>,
  TError,
  { shareId: number; data: BodyType<DocumentShareRequest> },
  TContext
> => {
  const mutationKey = ["update1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof update1>>,
    { shareId: number; data: BodyType<DocumentShareRequest> }
  > = (props) => {
    const { shareId, data } = props ?? {};

    return update1(shareId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Update1MutationResult = NonNullable<
  Awaited<ReturnType<typeof update1>>
>;
export type Update1MutationBody = BodyType<DocumentShareRequest>;
export type Update1MutationError = ErrorType<DocumentShareResponse>;

/**
 * @summary Update a share
 */
export const useUpdate1 = <
  TError = ErrorType<DocumentShareResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof update1>>,
      TError,
      { shareId: number; data: BodyType<DocumentShareRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof update1>>,
  TError,
  { shareId: number; data: BodyType<DocumentShareRequest> },
  TContext
> => {
  const mutationOptions = getUpdate1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Revokes document sharing
 * @summary Revoke a share
 */
export const revoke = (shareId: MaybeRef<number>) => {
  shareId = unref(shareId);

  return customInstance<void>({
    url: `/api/documents/shares/${shareId}`,
    method: "DELETE",
  });
};

export const getRevokeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revoke>>,
    TError,
    { shareId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { shareId: number },
  TContext
> => {
  const mutationKey = ["revoke"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revoke>>,
    { shareId: number }
  > = (props) => {
    const { shareId } = props ?? {};

    return revoke(shareId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof revoke>>
>;

export type RevokeMutationError = ErrorType<void>;

/**
 * @summary Revoke a share
 */
export const useRevoke = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revoke>>,
      TError,
      { shareId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { shareId: number },
  TContext
> => {
  const mutationOptions = getRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a category with its sub-categories
 * @summary Get a category by ID
 */
export const getById1 = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<CategoryResponse>({
    url: `/api/categories/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetById1QueryKey = (id?: MaybeRef<number>) => {
  return ["api", "categories", id] as const;
};

export const getGetById1QueryOptions = <
  TData = Awaited<ReturnType<typeof getById1>>,
  TError = ErrorType<CategoryResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetById1QueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById1>>> = ({
    signal,
  }) => getById1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>;
};

export type GetById1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getById1>>
>;
export type GetById1QueryError = ErrorType<CategoryResponse>;

/**
 * @summary Get a category by ID
 */

export function useGetById1<
  TData = Awaited<ReturnType<typeof getById1>>,
  TError = ErrorType<CategoryResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetById1QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Updates an existing category
 * @summary Update a category
 */
export const update2 = (
  id: MaybeRef<number>,
  categoryRequest: MaybeRef<CategoryRequest>,
) => {
  id = unref(id);
  categoryRequest = unref(categoryRequest);

  return customInstance<CategoryResponse>({
    url: `/api/categories/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: categoryRequest,
  });
};

export const getUpdate2MutationOptions = <
  TError = ErrorType<CategoryResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update2>>,
    TError,
    { id: number; data: BodyType<CategoryRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof update2>>,
  TError,
  { id: number; data: BodyType<CategoryRequest> },
  TContext
> => {
  const mutationKey = ["update2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof update2>>,
    { id: number; data: BodyType<CategoryRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return update2(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Update2MutationResult = NonNullable<
  Awaited<ReturnType<typeof update2>>
>;
export type Update2MutationBody = BodyType<CategoryRequest>;
export type Update2MutationError = ErrorType<CategoryResponse>;

/**
 * @summary Update a category
 */
export const useUpdate2 = <
  TError = ErrorType<CategoryResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof update2>>,
      TError,
      { id: number; data: BodyType<CategoryRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof update2>>,
  TError,
  { id: number; data: BodyType<CategoryRequest> },
  TContext
> => {
  const mutationOptions = getUpdate2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deletes a category if it has no sub-categories
 * @summary Delete a category
 */
export const delete1 = (id: MaybeRef<number>) => {
  id = unref(id);

  return customInstance<void>({
    url: `/api/categories/${id}`,
    method: "DELETE",
  });
};

export const getDelete1MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof delete1>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["delete1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof delete1>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return delete1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type Delete1MutationResult = NonNullable<
  Awaited<ReturnType<typeof delete1>>
>;

export type Delete1MutationError = ErrorType<void>;

/**
 * @summary Delete a category
 */
export const useDelete1 = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof delete1>>,
      TError,
      { id: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDelete1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all tags, optionally filtered by search query
 * @summary Get all tags
 */
export const getAll = (
  params?: MaybeRef<GetAllParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstance<TagResponse[]>({
    url: `/api/tags`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getGetAllQueryKey = (params?: MaybeRef<GetAllParams>) => {
  return ["api", "tags", ...(params ? [params] : [])] as const;
};

export const getGetAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getAll>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<GetAllParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({
    signal,
  }) => getAll(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll>>,
    TError,
    TData
  >;
};

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllQueryError = ErrorType<unknown>;

/**
 * @summary Get all tags
 */

export function useGetAll<
  TData = Awaited<ReturnType<typeof getAll>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<GetAllParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Creates a new document tag
 * @summary Create a new tag
 */
export const create = (
  tagRequest: MaybeRef<TagRequest>,
  signal?: AbortSignal,
) => {
  tagRequest = unref(tagRequest);

  return customInstance<TagResponse>({
    url: `/api/tags`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: tagRequest,
    signal,
  });
};

export const getCreateMutationOptions = <
  TError = ErrorType<TagResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create>>,
    TError,
    { data: BodyType<TagRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<TagRequest> },
  TContext
> => {
  const mutationKey = ["create"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof create>>,
    { data: BodyType<TagRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return create(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof create>>
>;
export type CreateMutationBody = BodyType<TagRequest>;
export type CreateMutationError = ErrorType<TagResponse>;

/**
 * @summary Create a new tag
 */
export const useCreate = <TError = ErrorType<TagResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof create>>,
      TError,
      { data: BodyType<TagRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<TagRequest> },
  TContext
> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all documents
 * @summary Get all documents
 */
export const getAll1 = (signal?: AbortSignal) => {
  return customInstance<DocumentResponse[]>({
    url: `/api/documents`,
    method: "GET",
    signal,
  });
};

export const getGetAll1QueryKey = () => {
  return ["api", "documents"] as const;
};

export const getGetAll1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAll1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll1>>> = ({
    signal,
  }) => getAll1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll1>>,
    TError,
    TData
  >;
};

export type GetAll1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAll1>>
>;
export type GetAll1QueryError = ErrorType<unknown>;

/**
 * @summary Get all documents
 */

export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAll1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Uploads a new document to the storage
 * @summary Upload a document
 */
export const upload = (
  uploadBody: MaybeRef<UploadBody>,
  signal?: AbortSignal,
) => {
  uploadBody = unref(uploadBody);
  const formData = new FormData();
  formData.append(`file`, uploadBody.file);
  formData.append(`data`, JSON.stringify(uploadBody.data));

  return customInstance<DocumentResponse>({
    url: `/api/documents`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getUploadMutationOptions = <
  TError = ErrorType<DocumentResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof upload>>,
    TError,
    { data: BodyType<UploadBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof upload>>,
  TError,
  { data: BodyType<UploadBody> },
  TContext
> => {
  const mutationKey = ["upload"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof upload>>,
    { data: BodyType<UploadBody> }
  > = (props) => {
    const { data } = props ?? {};

    return upload(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadMutationResult = NonNullable<
  Awaited<ReturnType<typeof upload>>
>;
export type UploadMutationBody = BodyType<UploadBody>;
export type UploadMutationError = ErrorType<DocumentResponse>;

/**
 * @summary Upload a document
 */
export const useUpload = <
  TError = ErrorType<DocumentResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof upload>>,
      TError,
      { data: BodyType<UploadBody> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof upload>>,
  TError,
  { data: BodyType<UploadBody> },
  TContext
> => {
  const mutationOptions = getUploadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all versions of a document
 * @summary Get all versions
 */
export const getVersions = (
  documentId: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);

  return customInstance<DocumentVersionResponse[]>({
    url: `/api/documents/${documentId}/versions`,
    method: "GET",
    signal,
  });
};

export const getGetVersionsQueryKey = (documentId?: MaybeRef<number>) => {
  return ["api", "documents", documentId, "versions"] as const;
};

export const getGetVersionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getVersions>>,
  TError = ErrorType<DocumentVersionResponse[]>,
>(
  documentId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetVersionsQueryKey(documentId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersions>>> = ({
    signal,
  }) => getVersions(documentId, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(documentId)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>;
};

export type GetVersionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersions>>
>;
export type GetVersionsQueryError = ErrorType<DocumentVersionResponse[]>;

/**
 * @summary Get all versions
 */

export function useGetVersions<
  TData = Awaited<ReturnType<typeof getVersions>>,
  TError = ErrorType<DocumentVersionResponse[]>,
>(
  documentId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVersions>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetVersionsQueryOptions(documentId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Uploads a new version of a document
 * @summary Upload new version
 */
export const uploadVersion = (
  documentId: MaybeRef<number>,
  uploadVersionBody: MaybeRef<UploadVersionBody>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);
  uploadVersionBody = unref(uploadVersionBody);
  const formData = new FormData();
  formData.append(`file`, uploadVersionBody.file);
  if (uploadVersionBody.data !== undefined) {
    formData.append(`data`, JSON.stringify(uploadVersionBody.data));
  }

  return customInstance<DocumentVersionResponse>({
    url: `/api/documents/${documentId}/versions`,
    method: "POST",
    headers: { "Content-Type": "multipart/form-data" },
    data: formData,
    signal,
  });
};

export const getUploadVersionMutationOptions = <
  TError = ErrorType<DocumentVersionResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadVersion>>,
    TError,
    { documentId: number; data: BodyType<UploadVersionBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadVersion>>,
  TError,
  { documentId: number; data: BodyType<UploadVersionBody> },
  TContext
> => {
  const mutationKey = ["uploadVersion"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadVersion>>,
    { documentId: number; data: BodyType<UploadVersionBody> }
  > = (props) => {
    const { documentId, data } = props ?? {};

    return uploadVersion(documentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadVersionMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadVersion>>
>;
export type UploadVersionMutationBody = BodyType<UploadVersionBody>;
export type UploadVersionMutationError = ErrorType<DocumentVersionResponse>;

/**
 * @summary Upload new version
 */
export const useUploadVersion = <
  TError = ErrorType<DocumentVersionResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadVersion>>,
      TError,
      { documentId: number; data: BodyType<UploadVersionBody> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof uploadVersion>>,
  TError,
  { documentId: number; data: BodyType<UploadVersionBody> },
  TContext
> => {
  const mutationOptions = getUploadVersionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all shares for a document
 * @summary Get document shares
 */
export const getSharesByDocument = (
  documentId: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);

  return customInstance<DocumentShareResponse[]>({
    url: `/api/documents/${documentId}/shares`,
    method: "GET",
    signal,
  });
};

export const getGetSharesByDocumentQueryKey = (
  documentId?: MaybeRef<number>,
) => {
  return ["api", "documents", documentId, "shares"] as const;
};

export const getGetSharesByDocumentQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharesByDocument>>,
  TError = ErrorType<DocumentShareResponse[]>,
>(
  documentId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSharesByDocument>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetSharesByDocumentQueryKey(documentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSharesByDocument>>
  > = ({ signal }) => getSharesByDocument(documentId, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(documentId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharesByDocument>>,
    TError,
    TData
  >;
};

export type GetSharesByDocumentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharesByDocument>>
>;
export type GetSharesByDocumentQueryError = ErrorType<DocumentShareResponse[]>;

/**
 * @summary Get document shares
 */

export function useGetSharesByDocument<
  TData = Awaited<ReturnType<typeof getSharesByDocument>>,
  TError = ErrorType<DocumentShareResponse[]>,
>(
  documentId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSharesByDocument>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSharesByDocumentQueryOptions(documentId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Shares a document with another user
 * @summary Share a document
 */
export const share = (
  documentId: MaybeRef<number>,
  documentShareRequest: MaybeRef<DocumentShareRequest>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);
  documentShareRequest = unref(documentShareRequest);

  return customInstance<DocumentShareResponse>({
    url: `/api/documents/${documentId}/shares`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: documentShareRequest,
    signal,
  });
};

export const getShareMutationOptions = <
  TError = ErrorType<DocumentShareResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof share>>,
    TError,
    { documentId: number; data: BodyType<DocumentShareRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof share>>,
  TError,
  { documentId: number; data: BodyType<DocumentShareRequest> },
  TContext
> => {
  const mutationKey = ["share"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof share>>,
    { documentId: number; data: BodyType<DocumentShareRequest> }
  > = (props) => {
    const { documentId, data } = props ?? {};

    return share(documentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof share>>
>;
export type ShareMutationBody = BodyType<DocumentShareRequest>;
export type ShareMutationError = ErrorType<DocumentShareResponse>;

/**
 * @summary Share a document
 */
export const useShare = <
  TError = ErrorType<DocumentShareResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof share>>,
      TError,
      { documentId: number; data: BodyType<DocumentShareRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof share>>,
  TError,
  { documentId: number; data: BodyType<DocumentShareRequest> },
  TContext
> => {
  const mutationOptions = getShareMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes all expired document shares
 * @summary Cleanup expired shares
 */
export const cleanupExpiredShares = (signal?: AbortSignal) => {
  return customInstance<number>({
    url: `/api/documents/shares/cleanup`,
    method: "POST",
    signal,
  });
};

export const getCleanupExpiredSharesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cleanupExpiredShares>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cleanupExpiredShares>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["cleanupExpiredShares"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cleanupExpiredShares>>,
    void
  > = () => {
    return cleanupExpiredShares();
  };

  return { mutationFn, ...mutationOptions };
};

export type CleanupExpiredSharesMutationResult = NonNullable<
  Awaited<ReturnType<typeof cleanupExpiredShares>>
>;

export type CleanupExpiredSharesMutationError = ErrorType<unknown>;

/**
 * @summary Cleanup expired shares
 */
export const useCleanupExpiredShares = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cleanupExpiredShares>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof cleanupExpiredShares>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getCleanupExpiredSharesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Searches documents by query parameters
 * @summary Search documents (GET)
 */
export const searchGet = (
  params?: MaybeRef<SearchGetParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstance<DocumentResponse[]>({
    url: `/api/documents/search`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getSearchGetQueryKey = (params?: MaybeRef<SearchGetParams>) => {
  return ["api", "documents", "search", ...(params ? [params] : [])] as const;
};

export const getSearchGetQueryOptions = <
  TData = Awaited<ReturnType<typeof searchGet>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<SearchGetParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchGet>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getSearchGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchGet>>> = ({
    signal,
  }) => searchGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchGet>>,
    TError,
    TData
  >;
};

export type SearchGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchGet>>
>;
export type SearchGetQueryError = ErrorType<unknown>;

/**
 * @summary Search documents (GET)
 */

export function useSearchGet<
  TData = Awaited<ReturnType<typeof searchGet>>,
  TError = ErrorType<unknown>,
>(
  params?: MaybeRef<SearchGetParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchGet>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Searches documents by various criteria
 * @summary Search documents
 */
export const search = (
  documentSearchRequest: MaybeRef<DocumentSearchRequest>,
  signal?: AbortSignal,
) => {
  documentSearchRequest = unref(documentSearchRequest);

  return customInstance<DocumentResponse[]>({
    url: `/api/documents/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: documentSearchRequest,
    signal,
  });
};

export const getSearchMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof search>>,
    TError,
    { data: BodyType<DocumentSearchRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof search>>,
  TError,
  { data: BodyType<DocumentSearchRequest> },
  TContext
> => {
  const mutationKey = ["search"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof search>>,
    { data: BodyType<DocumentSearchRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return search(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchMutationResult = NonNullable<
  Awaited<ReturnType<typeof search>>
>;
export type SearchMutationBody = BodyType<DocumentSearchRequest>;
export type SearchMutationError = ErrorType<unknown>;

/**
 * @summary Search documents
 */
export const useSearch = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof search>>,
      TError,
      { data: BodyType<DocumentSearchRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof search>>,
  TError,
  { data: BodyType<DocumentSearchRequest> },
  TContext
> => {
  const mutationOptions = getSearchMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a flat list of all categories
 * @summary Get all categories
 */
export const getAll2 = (signal?: AbortSignal) => {
  return customInstance<GetAll2200Item[]>({
    url: `/api/categories`,
    method: "GET",
    signal,
  });
};

export const getGetAll2QueryKey = () => {
  return ["api", "categories"] as const;
};

export const getGetAll2QueryOptions = <
  TData = Awaited<ReturnType<typeof getAll2>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAll2>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAll2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll2>>> = ({
    signal,
  }) => getAll2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll2>>,
    TError,
    TData
  >;
};

export type GetAll2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAll2>>
>;
export type GetAll2QueryError = ErrorType<unknown>;

/**
 * @summary Get all categories
 */

export function useGetAll2<
  TData = Awaited<ReturnType<typeof getAll2>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAll2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Creates a new document category
 * @summary Create a new category
 */
export const create1 = (
  categoryRequest: MaybeRef<CategoryRequest>,
  signal?: AbortSignal,
) => {
  categoryRequest = unref(categoryRequest);

  return customInstance<CategoryResponse>({
    url: `/api/categories`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: categoryRequest,
    signal,
  });
};

export const getCreate1MutationOptions = <
  TError = ErrorType<CategoryResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create1>>,
    TError,
    { data: BodyType<CategoryRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof create1>>,
  TError,
  { data: BodyType<CategoryRequest> },
  TContext
> => {
  const mutationKey = ["create1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof create1>>,
    { data: BodyType<CategoryRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return create1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Create1MutationResult = NonNullable<
  Awaited<ReturnType<typeof create1>>
>;
export type Create1MutationBody = BodyType<CategoryRequest>;
export type Create1MutationError = ErrorType<CategoryResponse>;

/**
 * @summary Create a new category
 */
export const useCreate1 = <
  TError = ErrorType<CategoryResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof create1>>,
      TError,
      { data: BodyType<CategoryRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof create1>>,
  TError,
  { data: BodyType<CategoryRequest> },
  TContext
> => {
  const mutationOptions = getCreate1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a tag by its ID
 * @summary Get a tag by ID
 */
export const getById2 = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<TagResponse>({
    url: `/api/tags/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetById2QueryKey = (id?: MaybeRef<number>) => {
  return ["api", "tags", id] as const;
};

export const getGetById2QueryOptions = <
  TData = Awaited<ReturnType<typeof getById2>>,
  TError = ErrorType<TagResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById2>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetById2QueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById2>>> = ({
    signal,
  }) => getById2(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getById2>>, TError, TData>;
};

export type GetById2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getById2>>
>;
export type GetById2QueryError = ErrorType<TagResponse>;

/**
 * @summary Get a tag by ID
 */

export function useGetById2<
  TData = Awaited<ReturnType<typeof getById2>>,
  TError = ErrorType<TagResponse>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetById2QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Deletes a tag
 * @summary Delete a tag
 */
export const delete2 = (id: MaybeRef<number>) => {
  id = unref(id);

  return customInstance<void>({ url: `/api/tags/${id}`, method: "DELETE" });
};

export const getDelete2MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof delete2>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof delete2>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["delete2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof delete2>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return delete2(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type Delete2MutationResult = NonNullable<
  Awaited<ReturnType<typeof delete2>>
>;

export type Delete2MutationError = ErrorType<void>;

/**
 * @summary Delete a tag
 */
export const useDelete2 = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof delete2>>,
      TError,
      { id: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof delete2>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDelete2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Downloads the document file
 * @summary Download document
 */
export const download = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<Blob>({
    url: `/api/documents/${id}/download`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getDownloadQueryKey = (id?: MaybeRef<number>) => {
  return ["api", "documents", id, "download"] as const;
};

export const getDownloadQueryOptions = <
  TData = Awaited<ReturnType<typeof download>>,
  TError = ErrorType<string>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof download>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getDownloadQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof download>>> = ({
    signal,
  }) => download(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof download>>, TError, TData>;
};

export type DownloadQueryResult = NonNullable<
  Awaited<ReturnType<typeof download>>
>;
export type DownloadQueryError = ErrorType<string>;

/**
 * @summary Download document
 */

export function useDownload<
  TData = Awaited<ReturnType<typeof download>>,
  TError = ErrorType<string>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof download>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDownloadQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns a presigned URL for downloading the document
 * @summary Get download URL
 */
export const getDownloadUrl = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<GetDownloadUrl200>({
    url: `/api/documents/${id}/download-url`,
    method: "GET",
    signal,
  });
};

export const getGetDownloadUrlQueryKey = (id?: MaybeRef<number>) => {
  return ["api", "documents", id, "download-url"] as const;
};

export const getGetDownloadUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof getDownloadUrl>>,
  TError = ErrorType<GetDownloadUrl404>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrl>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetDownloadUrlQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDownloadUrl>>> = ({
    signal,
  }) => getDownloadUrl(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDownloadUrl>>,
    TError,
    TData
  >;
};

export type GetDownloadUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDownloadUrl>>
>;
export type GetDownloadUrlQueryError = ErrorType<GetDownloadUrl404>;

/**
 * @summary Get download URL
 */

export function useGetDownloadUrl<
  TData = Awaited<ReturnType<typeof getDownloadUrl>>,
  TError = ErrorType<GetDownloadUrl404>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDownloadUrl>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDownloadUrlQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns details of a specific version
 * @summary Get specific version
 */
export const getVersion = (
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);
  versionNumber = unref(versionNumber);

  return customInstance<DocumentVersionResponse>({
    url: `/api/documents/${documentId}/versions/${versionNumber}`,
    method: "GET",
    signal,
  });
};

export const getGetVersionQueryKey = (
  documentId?: MaybeRef<number>,
  versionNumber?: MaybeRef<number>,
) => {
  return ["api", "documents", documentId, "versions", versionNumber] as const;
};

export const getGetVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof getVersion>>,
  TError = ErrorType<DocumentVersionResponse>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVersion>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetVersionQueryKey(documentId, versionNumber);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersion>>> = ({
    signal,
  }) => getVersion(documentId, versionNumber, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!(unref(documentId) && unref(versionNumber))),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getVersion>>, TError, TData>;
};

export type GetVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersion>>
>;
export type GetVersionQueryError = ErrorType<DocumentVersionResponse>;

/**
 * @summary Get specific version
 */

export function useGetVersion<
  TData = Awaited<ReturnType<typeof getVersion>>,
  TError = ErrorType<DocumentVersionResponse>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVersion>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetVersionQueryOptions(
    documentId,
    versionNumber,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Downloads a specific version of the document
 * @summary Download version
 */
export const downloadVersion = (
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);
  versionNumber = unref(versionNumber);

  return customInstance<Blob>({
    url: `/api/documents/${documentId}/versions/${versionNumber}/download`,
    method: "GET",
    responseType: "blob",
    signal,
  });
};

export const getDownloadVersionQueryKey = (
  documentId?: MaybeRef<number>,
  versionNumber?: MaybeRef<number>,
) => {
  return [
    "api",
    "documents",
    documentId,
    "versions",
    versionNumber,
    "download",
  ] as const;
};

export const getDownloadVersionQueryOptions = <
  TData = Awaited<ReturnType<typeof downloadVersion>>,
  TError = ErrorType<string>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVersion>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getDownloadVersionQueryKey(documentId, versionNumber);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadVersion>>> = ({
    signal,
  }) => downloadVersion(documentId, versionNumber, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!(unref(documentId) && unref(versionNumber))),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof downloadVersion>>,
    TError,
    TData
  >;
};

export type DownloadVersionQueryResult = NonNullable<
  Awaited<ReturnType<typeof downloadVersion>>
>;
export type DownloadVersionQueryError = ErrorType<string>;

/**
 * @summary Download version
 */

export function useDownloadVersion<
  TData = Awaited<ReturnType<typeof downloadVersion>>,
  TError = ErrorType<string>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof downloadVersion>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getDownloadVersionQueryOptions(
    documentId,
    versionNumber,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns a presigned URL for downloading a specific version
 * @summary Get version download URL
 */
export const getVersionDownloadUrl = (
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  documentId = unref(documentId);
  versionNumber = unref(versionNumber);

  return customInstance<GetVersionDownloadUrl200>({
    url: `/api/documents/${documentId}/versions/${versionNumber}/download-url`,
    method: "GET",
    signal,
  });
};

export const getGetVersionDownloadUrlQueryKey = (
  documentId?: MaybeRef<number>,
  versionNumber?: MaybeRef<number>,
) => {
  return [
    "api",
    "documents",
    documentId,
    "versions",
    versionNumber,
    "download-url",
  ] as const;
};

export const getGetVersionDownloadUrlQueryOptions = <
  TData = Awaited<ReturnType<typeof getVersionDownloadUrl>>,
  TError = ErrorType<GetVersionDownloadUrl404>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVersionDownloadUrl>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetVersionDownloadUrlQueryKey(documentId, versionNumber);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getVersionDownloadUrl>>
  > = ({ signal }) => getVersionDownloadUrl(documentId, versionNumber, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!(unref(documentId) && unref(versionNumber))),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVersionDownloadUrl>>,
    TError,
    TData
  >;
};

export type GetVersionDownloadUrlQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersionDownloadUrl>>
>;
export type GetVersionDownloadUrlQueryError =
  ErrorType<GetVersionDownloadUrl404>;

/**
 * @summary Get version download URL
 */

export function useGetVersionDownloadUrl<
  TData = Awaited<ReturnType<typeof getVersionDownloadUrl>>,
  TError = ErrorType<GetVersionDownloadUrl404>,
>(
  documentId: MaybeRef<number>,
  versionNumber: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getVersionDownloadUrl>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetVersionDownloadUrlQueryOptions(
    documentId,
    versionNumber,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns all documents shared with a specific user
 * @summary Get shares with user
 */
export const getSharesWithUser = (
  userId: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  userId = unref(userId);

  return customInstance<DocumentShareResponse[]>({
    url: `/api/documents/shared-with/${userId}`,
    method: "GET",
    signal,
  });
};

export const getGetSharesWithUserQueryKey = (userId?: MaybeRef<string>) => {
  return ["api", "documents", "shared-with", userId] as const;
};

export const getGetSharesWithUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharesWithUser>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSharesWithUser>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetSharesWithUserQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSharesWithUser>>
  > = ({ signal }) => getSharesWithUser(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharesWithUser>>,
    TError,
    TData
  >;
};

export type GetSharesWithUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharesWithUser>>
>;
export type GetSharesWithUserQueryError = ErrorType<unknown>;

/**
 * @summary Get shares with user
 */

export function useGetSharesWithUser<
  TData = Awaited<ReturnType<typeof getSharesWithUser>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSharesWithUser>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSharesWithUserQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns all documents shared with the current user
 * @summary Get documents shared with me
 */
export const getSharedWithMe = (signal?: AbortSignal) => {
  return customInstance<DocumentShareResponse[]>({
    url: `/api/documents/shared-with-me`,
    method: "GET",
    signal,
  });
};

export const getGetSharedWithMeQueryKey = () => {
  return ["api", "documents", "shared-with-me"] as const;
};

export const getGetSharedWithMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getSharedWithMe>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSharedWithMe>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetSharedWithMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSharedWithMe>>> = ({
    signal,
  }) => getSharedWithMe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSharedWithMe>>,
    TError,
    TData
  >;
};

export type GetSharedWithMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSharedWithMe>>
>;
export type GetSharedWithMeQueryError = ErrorType<unknown>;

/**
 * @summary Get documents shared with me
 */

export function useGetSharedWithMe<
  TData = Awaited<ReturnType<typeof getSharedWithMe>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSharedWithMe>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSharedWithMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns all public documents
 * @summary Get public documents
 */
export const getPublic = (signal?: AbortSignal) => {
  return customInstance<DocumentResponse[]>({
    url: `/api/documents/public`,
    method: "GET",
    signal,
  });
};

export const getGetPublicQueryKey = () => {
  return ["api", "documents", "public"] as const;
};

export const getGetPublicQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublic>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getPublic>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetPublicQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPublic>>> = ({
    signal,
  }) => getPublic(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublic>>,
    TError,
    TData
  >;
};

export type GetPublicQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublic>>
>;
export type GetPublicQueryError = ErrorType<unknown>;

/**
 * @summary Get public documents
 */

export function useGetPublic<
  TData = Awaited<ReturnType<typeof getPublic>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getPublic>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPublicQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns documents uploaded by the current user
 * @summary Get my documents
 */
export const getMyDocuments = (signal?: AbortSignal) => {
  return customInstance<DocumentResponse[]>({
    url: `/api/documents/my`,
    method: "GET",
    signal,
  });
};

export const getGetMyDocumentsQueryKey = () => {
  return ["api", "documents", "my"] as const;
};

export const getGetMyDocumentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMyDocuments>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMyDocuments>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetMyDocumentsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyDocuments>>> = ({
    signal,
  }) => getMyDocuments(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMyDocuments>>,
    TError,
    TData
  >;
};

export type GetMyDocumentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMyDocuments>>
>;
export type GetMyDocumentsQueryError = ErrorType<unknown>;

/**
 * @summary Get my documents
 */

export function useGetMyDocuments<
  TData = Awaited<ReturnType<typeof getMyDocuments>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMyDocuments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMyDocumentsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns all documents in a category
 * @summary Get documents by category
 */
export const getByCategory = (
  categoryId: MaybeRef<number>,
  signal?: AbortSignal,
) => {
  categoryId = unref(categoryId);

  return customInstance<DocumentResponse[]>({
    url: `/api/documents/category/${categoryId}`,
    method: "GET",
    signal,
  });
};

export const getGetByCategoryQueryKey = (categoryId?: MaybeRef<number>) => {
  return ["api", "documents", "category", categoryId] as const;
};

export const getGetByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getByCategory>>,
  TError = ErrorType<DocumentResponse[]>,
>(
  categoryId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByCategory>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByCategoryQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByCategory>>> = ({
    signal,
  }) => getByCategory(categoryId, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(categoryId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getByCategory>>,
    TError,
    TData
  >;
};

export type GetByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByCategory>>
>;
export type GetByCategoryQueryError = ErrorType<DocumentResponse[]>;

/**
 * @summary Get documents by category
 */

export function useGetByCategory<
  TData = Awaited<ReturnType<typeof getByCategory>>,
  TError = ErrorType<DocumentResponse[]>,
>(
  categoryId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByCategory>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByCategoryQueryOptions(categoryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns the complete category hierarchy as a tree
 * @summary Get category tree
 */
export const getTree = (signal?: AbortSignal) => {
  return customInstance<GetTree200Item[]>({
    url: `/api/categories/tree`,
    method: "GET",
    signal,
  });
};

export const getGetTreeQueryKey = () => {
  return ["api", "categories", "tree"] as const;
};

export const getGetTreeQueryOptions = <
  TData = Awaited<ReturnType<typeof getTree>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getTree>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetTreeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTree>>> = ({
    signal,
  }) => getTree(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTree>>,
    TError,
    TData
  >;
};

export type GetTreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTree>>
>;
export type GetTreeQueryError = ErrorType<unknown>;

/**
 * @summary Get category tree
 */

export function useGetTree<
  TData = Awaited<ReturnType<typeof getTree>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTree>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTreeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Returns only top-level categories without parents
 * @summary Get root categories
 */
export const getRootCategories = (signal?: AbortSignal) => {
  return customInstance<GetRootCategories200Item[]>({
    url: `/api/categories/root`,
    method: "GET",
    signal,
  });
};

export const getGetRootCategoriesQueryKey = () => {
  return ["api", "categories", "root"] as const;
};

export const getGetRootCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRootCategories>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getRootCategories>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetRootCategoriesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRootCategories>>
  > = ({ signal }) => getRootCategories(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRootCategories>>,
    TError,
    TData
  >;
};

export type GetRootCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRootCategories>>
>;
export type GetRootCategoriesQueryError = ErrorType<unknown>;

/**
 * @summary Get root categories
 */

export function useGetRootCategories<
  TData = Awaited<ReturnType<typeof getRootCategories>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRootCategories>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRootCategoriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Deletes a specific metadata key
 * @summary Delete metadata key
 */
export const deleteMetadataKey = (
  id: MaybeRef<number>,
  key: MaybeRef<string>,
) => {
  id = unref(id);
  key = unref(key);

  return customInstance<void>({
    url: `/api/documents/${id}/metadata/${key}`,
    method: "DELETE",
  });
};

export const getDeleteMetadataKeyMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMetadataKey>>,
    TError,
    { id: number; key: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMetadataKey>>,
  TError,
  { id: number; key: string },
  TContext
> => {
  const mutationKey = ["deleteMetadataKey"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMetadataKey>>,
    { id: number; key: string }
  > = (props) => {
    const { id, key } = props ?? {};

    return deleteMetadataKey(id, key);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMetadataKeyMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMetadataKey>>
>;

export type DeleteMetadataKeyMutationError = ErrorType<void>;

/**
 * @summary Delete metadata key
 */
export const useDeleteMetadataKey = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMetadataKey>>,
      TError,
      { id: number; key: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof deleteMetadataKey>>,
  TError,
  { id: number; key: string },
  TContext
> => {
  const mutationOptions = getDeleteMetadataKeyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
