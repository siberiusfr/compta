/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * OAuth2 Authorization Server API
 * OAuth2 Authorization Server for Compta microservices. Provides token issuance and user authentication.
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { computed, unref } from "vue";
import type { MaybeRef } from "vue";

import { customInstance } from "../../../api/axios-instance";
import type { ErrorType, BodyType } from "../../../api/axios-instance";
export interface UpdateUserRequest {
  /**
   * @minLength 0
   * @maxLength 100
   */
  firstName?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  lastName?: string;
  email?: string;
  roles?: string[];
}

export interface UserResponse {
  id?: string;
  username?: string;
  email?: string;
  firstName?: string;
  lastName?: string;
  enabled?: boolean;
  accountNonExpired?: boolean;
  accountNonLocked?: boolean;
  credentialsNonExpired?: boolean;
  roles?: string[];
  createdAt?: string;
  updatedAt?: string;
}

export interface UpdateRoleRequest {
  /**
   * @minLength 0
   * @maxLength 255
   */
  description?: string;
}

export interface RoleResponse {
  id?: string;
  name?: string;
  description?: string;
  createdAt?: string;
}

export interface UpdateClientRequest {
  clientSecret?: string;
  /** @minLength 1 */
  clientName: string;
  clientAuthenticationMethods?: string[];
  authorizationGrantTypes?: string[];
  redirectUris?: string[];
  postLogoutRedirectUris?: string[];
  scopes?: string[];
  requireAuthorizationConsent?: boolean;
  requireProofKey?: boolean;
  reuseRefreshTokens?: boolean;
  accessTokenTimeToLive?: string;
  authorizationCodeTimeToLive?: string;
  refreshTokenTimeToLive?: string;
}

export interface ClientResponse {
  id?: string;
  clientId?: string;
  clientIdIssuedAt?: string;
  clientName?: string;
  clientAuthenticationMethods?: string[];
  authorizationGrantTypes?: string[];
  redirectUris?: string[];
  postLogoutRedirectUris?: string[];
  scopes?: string[];
  requireAuthorizationConsent?: boolean;
  requireProofKey?: boolean;
  reuseRefreshTokens?: boolean;
  accessTokenTimeToLiveSeconds?: number;
  authorizationCodeTimeToLiveSeconds?: number;
  refreshTokenTimeToLiveSeconds?: number;
  clientSecretExpiresAt?: string;
}

export interface RevocationRequest {
  /** @minLength 1 */
  token: string;
  tokenTypeHint?: string;
}

export interface IntrospectionRequest {
  /** @minLength 1 */
  token: string;
  tokenTypeHint?: string;
}

export interface IntrospectionResponse {
  active?: boolean;
  clientId?: string;
  tokenType?: string;
  exp?: string;
  iat?: string;
  sub?: string;
  aud?: string;
  iss?: string;
  scope?: string[];
  username?: string;
  email?: string;
  roles?: string[];
}

export interface CreateUserRequest {
  /**
   * @minLength 3
   * @maxLength 50
   */
  username: string;
  /**
   * @minLength 8
   * @maxLength 100
   */
  password: string;
  /** @minLength 1 */
  email: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  firstName?: string;
  /**
   * @minLength 0
   * @maxLength 100
   */
  lastName?: string;
  roles?: string[];
}

export interface ChangePasswordRequest {
  /** @minLength 1 */
  currentPassword: string;
  /**
   * @minLength 8
   * @maxLength 100
   */
  newPassword: string;
}

export interface PasswordResetRequest {
  /** @minLength 1 */
  email: string;
}

export interface PasswordResetConfirmRequest {
  /**
   * @minLength 36
   * @maxLength 36
   */
  token: string;
  /**
   * @minLength 8
   * @maxLength 100
   */
  password: string;
}

export interface EmailVerificationRequest {
  /** @minLength 1 */
  email: string;
}

export interface CreateRoleRequest {
  /**
   * @minLength 2
   * @maxLength 50
   */
  name: string;
  /**
   * @minLength 0
   * @maxLength 255
   */
  description?: string;
}

export interface CreateClientRequest {
  /** @minLength 1 */
  clientId: string;
  clientSecret?: string;
  /** @minLength 1 */
  clientName: string;
  clientAuthenticationMethods: string[];
  authorizationGrantTypes: string[];
  redirectUris: string[];
  postLogoutRedirectUris?: string[];
  scopes: string[];
  requireAuthorizationConsent?: boolean;
  requireProofKey?: boolean;
  reuseRefreshTokens?: boolean;
  accessTokenTimeToLive?: string;
  authorizationCodeTimeToLive?: string;
  refreshTokenTimeToLive?: string;
}

export interface UserInfoResponse {
  sub?: string;
  name?: string;
  givenName?: string;
  familyName?: string;
  email?: string;
  emailVerified?: boolean;
  roles?: string[];
  tenantId?: string;
}

export interface Link {
  href?: string;
  templated?: boolean;
}

export type AssignRolesBody = { [key: string]: string[] };

export type ConfirmEmailVerificationParams = {
  /**
   * The verification token from the email
   */
  token: string;
};

export type GetAllClients200 = { [key: string]: unknown };

export type RotateClientSecret200 = { [key: string]: string };

export type Links200One = { [key: string]: { [key: string]: Link } };

export type Links200Two = { [key: string]: { [key: string]: Link } };

export type Links200Three = { [key: string]: { [key: string]: Link } };

export type Health200One = { [key: string]: unknown };

export type Health200Two = { [key: string]: unknown };

export type Health200Three = { [key: string]: unknown };

/**
 * Retrieve a specific user by ID
 * @summary Get user by ID
 */
export const getUserById = (id: MaybeRef<string>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<UserResponse>({
    url: `/api/users/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetUserByIdQueryKey = (id?: MaybeRef<string>) => {
  return ["api", "users", id] as const;
};

export const getGetUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetUserByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({
    signal,
  }) => getUserById(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>;
};

export type GetUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserById>>
>;
export type GetUserByIdQueryError = ErrorType<unknown>;

/**
 * @summary Get user by ID
 */

export function useGetUserById<
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Update an existing user
 * @summary Update user
 */
export const updateUser = (
  id: MaybeRef<string>,
  updateUserRequest: MaybeRef<UpdateUserRequest>,
) => {
  id = unref(id);
  updateUserRequest = unref(updateUserRequest);

  return customInstance<UserResponse>({
    url: `/api/users/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateUserRequest,
  });
};

export const getUpdateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: BodyType<UpdateUserRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: BodyType<UpdateUserRequest> },
  TContext
> => {
  const mutationKey = ["updateUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: BodyType<UpdateUserRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateUser(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type UpdateUserMutationBody = BodyType<UpdateUserRequest>;
export type UpdateUserMutationError = ErrorType<unknown>;

/**
 * @summary Update user
 */
export const useUpdateUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: BodyType<UpdateUserRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: BodyType<UpdateUserRequest> },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete a user
 * @summary Delete user
 */
export const deleteUser = (id: MaybeRef<string>) => {
  id = unref(id);

  return customInstance<void>({ url: `/api/users/${id}`, method: "DELETE" });
};

export const getDeleteUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteUser(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;

export type DeleteUserMutationError = ErrorType<unknown>;

/**
 * @summary Delete user
 */
export const useDeleteUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a specific role by ID
 * @summary Get role by ID
 */
export const getRoleById = (id: MaybeRef<string>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<RoleResponse>({
    url: `/api/roles/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetRoleByIdQueryKey = (id?: MaybeRef<string>) => {
  return ["api", "roles", id] as const;
};

export const getGetRoleByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetRoleByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleById>>> = ({
    signal,
  }) => getRoleById(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getRoleById>>, TError, TData>;
};

export type GetRoleByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoleById>>
>;
export type GetRoleByIdQueryError = ErrorType<unknown>;

/**
 * @summary Get role by ID
 */

export function useGetRoleById<
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoleByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Update an existing role
 * @summary Update role
 */
export const updateRole = (
  id: MaybeRef<string>,
  updateRoleRequest: MaybeRef<UpdateRoleRequest>,
) => {
  id = unref(id);
  updateRoleRequest = unref(updateRoleRequest);

  return customInstance<RoleResponse>({
    url: `/api/roles/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateRoleRequest,
  });
};

export const getUpdateRoleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRole>>,
    TError,
    { id: string; data: BodyType<UpdateRoleRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { id: string; data: BodyType<UpdateRoleRequest> },
  TContext
> => {
  const mutationKey = ["updateRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRole>>,
    { id: string; data: BodyType<UpdateRoleRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateRole(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRole>>
>;
export type UpdateRoleMutationBody = BodyType<UpdateRoleRequest>;
export type UpdateRoleMutationError = ErrorType<unknown>;

/**
 * @summary Update role
 */
export const useUpdateRole = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRole>>,
      TError,
      { id: string; data: BodyType<UpdateRoleRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { id: string; data: BodyType<UpdateRoleRequest> },
  TContext
> => {
  const mutationOptions = getUpdateRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete a role
 * @summary Delete role
 */
export const deleteRole = (id: MaybeRef<string>) => {
  id = unref(id);

  return customInstance<void>({ url: `/api/roles/${id}`, method: "DELETE" });
};

export const getDeleteRoleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRole>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRole>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteRole(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRole>>
>;

export type DeleteRoleMutationError = ErrorType<unknown>;

/**
 * @summary Delete role
 */
export const useDeleteRole = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRole>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a specific OAuth2 client by its client ID
 * @summary Get OAuth2 client by ID
 */
export const getClientById = (
  clientId: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  clientId = unref(clientId);

  return customInstance<ClientResponse>({
    url: `/api/clients/${clientId}`,
    method: "GET",
    signal,
  });
};

export const getGetClientByIdQueryKey = (clientId?: MaybeRef<string>) => {
  return ["api", "clients", clientId] as const;
};

export const getGetClientByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getClientById>>,
  TError = ErrorType<unknown>,
>(
  clientId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetClientByIdQueryKey(clientId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getClientById>>> = ({
    signal,
  }) => getClientById(clientId, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(clientId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getClientById>>,
    TError,
    TData
  >;
};

export type GetClientByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getClientById>>
>;
export type GetClientByIdQueryError = ErrorType<unknown>;

/**
 * @summary Get OAuth2 client by ID
 */

export function useGetClientById<
  TData = Awaited<ReturnType<typeof getClientById>>,
  TError = ErrorType<unknown>,
>(
  clientId: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getClientById>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetClientByIdQueryOptions(clientId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Update an existing OAuth2 client
 * @summary Update OAuth2 client
 */
export const updateClient = (
  clientId: MaybeRef<string>,
  updateClientRequest: MaybeRef<UpdateClientRequest>,
) => {
  clientId = unref(clientId);
  updateClientRequest = unref(updateClientRequest);

  return customInstance<ClientResponse>({
    url: `/api/clients/${clientId}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateClientRequest,
  });
};

export const getUpdateClientMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateClient>>,
    TError,
    { clientId: string; data: BodyType<UpdateClientRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateClient>>,
  TError,
  { clientId: string; data: BodyType<UpdateClientRequest> },
  TContext
> => {
  const mutationKey = ["updateClient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateClient>>,
    { clientId: string; data: BodyType<UpdateClientRequest> }
  > = (props) => {
    const { clientId, data } = props ?? {};

    return updateClient(clientId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateClientMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateClient>>
>;
export type UpdateClientMutationBody = BodyType<UpdateClientRequest>;
export type UpdateClientMutationError = ErrorType<unknown>;

/**
 * @summary Update OAuth2 client
 */
export const useUpdateClient = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateClient>>,
      TError,
      { clientId: string; data: BodyType<UpdateClientRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof updateClient>>,
  TError,
  { clientId: string; data: BodyType<UpdateClientRequest> },
  TContext
> => {
  const mutationOptions = getUpdateClientMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Delete an OAuth2 client
 * @summary Delete OAuth2 client
 */
export const deleteClient = (clientId: MaybeRef<string>) => {
  clientId = unref(clientId);

  return customInstance<void>({
    url: `/api/clients/${clientId}`,
    method: "DELETE",
  });
};

export const getDeleteClientMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteClient>>,
    TError,
    { clientId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteClient>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationKey = ["deleteClient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteClient>>,
    { clientId: string }
  > = (props) => {
    const { clientId } = props ?? {};

    return deleteClient(clientId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteClientMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteClient>>
>;

export type DeleteClientMutationError = ErrorType<unknown>;

/**
 * @summary Delete OAuth2 client
 */
export const useDeleteClient = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteClient>>,
      TError,
      { clientId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof deleteClient>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationOptions = getDeleteClientMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Revoke an OAuth2 token. The token will be invalidated immediately.
 * @summary Revoke token
 */
export const revoke = (
  revocationRequest: MaybeRef<RevocationRequest>,
  signal?: AbortSignal,
) => {
  revocationRequest = unref(revocationRequest);

  return customInstance<void>({
    url: `/oauth2/revoke`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: revocationRequest,
    signal,
  });
};

export const getRevokeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revoke>>,
    TError,
    { data: BodyType<RevocationRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { data: BodyType<RevocationRequest> },
  TContext
> => {
  const mutationKey = ["revoke"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revoke>>,
    { data: BodyType<RevocationRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return revoke(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeMutationResult = NonNullable<
  Awaited<ReturnType<typeof revoke>>
>;
export type RevokeMutationBody = BodyType<RevocationRequest>;
export type RevokeMutationError = ErrorType<unknown>;

/**
 * @summary Revoke token
 */
export const useRevoke = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revoke>>,
      TError,
      { data: BodyType<RevocationRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof revoke>>,
  TError,
  { data: BodyType<RevocationRequest> },
  TContext
> => {
  const mutationOptions = getRevokeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Introspect an OAuth2 token to get its metadata and validity status
 * @summary Introspect token
 */
export const introspect = (
  introspectionRequest: MaybeRef<IntrospectionRequest>,
  signal?: AbortSignal,
) => {
  introspectionRequest = unref(introspectionRequest);

  return customInstance<IntrospectionResponse>({
    url: `/oauth2/introspect`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: introspectionRequest,
    signal,
  });
};

export const getIntrospectMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof introspect>>,
    TError,
    { data: BodyType<IntrospectionRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof introspect>>,
  TError,
  { data: BodyType<IntrospectionRequest> },
  TContext
> => {
  const mutationKey = ["introspect"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof introspect>>,
    { data: BodyType<IntrospectionRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return introspect(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type IntrospectMutationResult = NonNullable<
  Awaited<ReturnType<typeof introspect>>
>;
export type IntrospectMutationBody = BodyType<IntrospectionRequest>;
export type IntrospectMutationError = ErrorType<unknown>;

/**
 * @summary Introspect token
 */
export const useIntrospect = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof introspect>>,
      TError,
      { data: BodyType<IntrospectionRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof introspect>>,
  TError,
  { data: BodyType<IntrospectionRequest> },
  TContext
> => {
  const mutationOptions = getIntrospectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve all users
 * @summary Get all users
 */
export const getAllUsers = (signal?: AbortSignal) => {
  return customInstance<UserResponse[]>({
    url: `/api/users`,
    method: "GET",
    signal,
  });
};

export const getGetAllUsersQueryKey = () => {
  return ["api", "users"] as const;
};

export const getGetAllUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAllUsersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({
    signal,
  }) => getAllUsers(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllUsers>>,
    TError,
    TData
  >;
};

export type GetAllUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllUsers>>
>;
export type GetAllUsersQueryError = ErrorType<unknown>;

/**
 * @summary Get all users
 */

export function useGetAllUsers<
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllUsersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Create a new user with roles
 * @summary Create a new user
 */
export const createUser = (
  createUserRequest: MaybeRef<CreateUserRequest>,
  signal?: AbortSignal,
) => {
  createUserRequest = unref(createUserRequest);

  return customInstance<UserResponse>({
    url: `/api/users`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createUserRequest,
    signal,
  });
};

export const getCreateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserRequest> },
  TContext
> => {
  const mutationKey = ["createUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: BodyType<CreateUserRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type CreateUserMutationBody = BodyType<CreateUserRequest>;
export type CreateUserMutationError = ErrorType<unknown>;

/**
 * @summary Create a new user
 */
export const useCreateUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: BodyType<CreateUserRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserRequest> },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve all roles for a user
 * @summary Get user roles
 */
export const getUserRoles = (id: MaybeRef<string>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<string[]>({
    url: `/api/users/${id}/roles`,
    method: "GET",
    signal,
  });
};

export const getGetUserRolesQueryKey = (id?: MaybeRef<string>) => {
  return ["api", "users", id, "roles"] as const;
};

export const getGetUserRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserRoles>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetUserRolesQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserRoles>>> = ({
    signal,
  }) => getUserRoles(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>;
};

export type GetUserRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserRoles>>
>;
export type GetUserRolesQueryError = ErrorType<unknown>;

/**
 * @summary Get user roles
 */

export function useGetUserRoles<
  TData = Awaited<ReturnType<typeof getUserRoles>>,
  TError = ErrorType<unknown>,
>(
  id: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserRoles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserRolesQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Assign roles to a user
 * @summary Assign roles to user
 */
export const assignRoles = (
  id: MaybeRef<string>,
  assignRolesBody: MaybeRef<AssignRolesBody>,
  signal?: AbortSignal,
) => {
  id = unref(id);
  assignRolesBody = unref(assignRolesBody);

  return customInstance<void>({
    url: `/api/users/${id}/roles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: assignRolesBody,
    signal,
  });
};

export const getAssignRolesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignRoles>>,
    TError,
    { id: string; data: BodyType<AssignRolesBody> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignRoles>>,
  TError,
  { id: string; data: BodyType<AssignRolesBody> },
  TContext
> => {
  const mutationKey = ["assignRoles"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignRoles>>,
    { id: string; data: BodyType<AssignRolesBody> }
  > = (props) => {
    const { id, data } = props ?? {};

    return assignRoles(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AssignRolesMutationResult = NonNullable<
  Awaited<ReturnType<typeof assignRoles>>
>;
export type AssignRolesMutationBody = BodyType<AssignRolesBody>;
export type AssignRolesMutationError = ErrorType<unknown>;

/**
 * @summary Assign roles to user
 */
export const useAssignRoles = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignRoles>>,
      TError,
      { id: string; data: BodyType<AssignRolesBody> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof assignRoles>>,
  TError,
  { id: string; data: BodyType<AssignRolesBody> },
  TContext
> => {
  const mutationOptions = getAssignRolesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Change password for a user
 * @summary Change user password
 */
export const changePassword = (
  id: MaybeRef<string>,
  changePasswordRequest: MaybeRef<ChangePasswordRequest>,
  signal?: AbortSignal,
) => {
  id = unref(id);
  changePasswordRequest = unref(changePasswordRequest);

  return customInstance<void>({
    url: `/api/users/${id}/password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: changePasswordRequest,
    signal,
  });
};

export const getChangePasswordMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePassword>>,
    TError,
    { id: string; data: BodyType<ChangePasswordRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePassword>>,
  TError,
  { id: string; data: BodyType<ChangePasswordRequest> },
  TContext
> => {
  const mutationKey = ["changePassword"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePassword>>,
    { id: string; data: BodyType<ChangePasswordRequest> }
  > = (props) => {
    const { id, data } = props ?? {};

    return changePassword(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangePasswordMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePassword>>
>;
export type ChangePasswordMutationBody = BodyType<ChangePasswordRequest>;
export type ChangePasswordMutationError = ErrorType<unknown>;

/**
 * @summary Change user password
 */
export const useChangePassword = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePassword>>,
      TError,
      { id: string; data: BodyType<ChangePasswordRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof changePassword>>,
  TError,
  { id: string; data: BodyType<ChangePasswordRequest> },
  TContext
> => {
  const mutationOptions = getChangePasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sends a password reset email to the user's email address
 * @summary Initiate password reset
 */
export const initiatePasswordReset = (
  passwordResetRequest: MaybeRef<PasswordResetRequest>,
  signal?: AbortSignal,
) => {
  passwordResetRequest = unref(passwordResetRequest);

  return customInstance<string>({
    url: `/api/users/password/reset`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: passwordResetRequest,
    signal,
  });
};

export const getInitiatePasswordResetMutationOptions = <
  TError = ErrorType<string>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof initiatePasswordReset>>,
    TError,
    { data: BodyType<PasswordResetRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof initiatePasswordReset>>,
  TError,
  { data: BodyType<PasswordResetRequest> },
  TContext
> => {
  const mutationKey = ["initiatePasswordReset"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof initiatePasswordReset>>,
    { data: BodyType<PasswordResetRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return initiatePasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InitiatePasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof initiatePasswordReset>>
>;
export type InitiatePasswordResetMutationBody = BodyType<PasswordResetRequest>;
export type InitiatePasswordResetMutationError = ErrorType<string>;

/**
 * @summary Initiate password reset
 */
export const useInitiatePasswordReset = <
  TError = ErrorType<string>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof initiatePasswordReset>>,
      TError,
      { data: BodyType<PasswordResetRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof initiatePasswordReset>>,
  TError,
  { data: BodyType<PasswordResetRequest> },
  TContext
> => {
  const mutationOptions = getInitiatePasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Resets the user's password using a valid reset token
 * @summary Confirm password reset
 */
export const confirmPasswordReset = (
  passwordResetConfirmRequest: MaybeRef<PasswordResetConfirmRequest>,
  signal?: AbortSignal,
) => {
  passwordResetConfirmRequest = unref(passwordResetConfirmRequest);

  return customInstance<string>({
    url: `/api/users/password/reset/confirm`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: passwordResetConfirmRequest,
    signal,
  });
};

export const getConfirmPasswordResetMutationOptions = <
  TError = ErrorType<string>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    TError,
    { data: BodyType<PasswordResetConfirmRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: BodyType<PasswordResetConfirmRequest> },
  TContext
> => {
  const mutationKey = ["confirmPasswordReset"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmPasswordReset>>,
    { data: BodyType<PasswordResetConfirmRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return confirmPasswordReset(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmPasswordReset>>
>;
export type ConfirmPasswordResetMutationBody =
  BodyType<PasswordResetConfirmRequest>;
export type ConfirmPasswordResetMutationError = ErrorType<string>;

/**
 * @summary Confirm password reset
 */
export const useConfirmPasswordReset = <
  TError = ErrorType<string>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmPasswordReset>>,
      TError,
      { data: BodyType<PasswordResetConfirmRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof confirmPasswordReset>>,
  TError,
  { data: BodyType<PasswordResetConfirmRequest> },
  TContext
> => {
  const mutationOptions = getConfirmPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sends a verification email to the user's email address
 * @summary Initiate email verification
 */
export const initiateEmailVerification = (
  emailVerificationRequest: MaybeRef<EmailVerificationRequest>,
  signal?: AbortSignal,
) => {
  emailVerificationRequest = unref(emailVerificationRequest);

  return customInstance<string>({
    url: `/api/users/email/verify`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: emailVerificationRequest,
    signal,
  });
};

export const getInitiateEmailVerificationMutationOptions = <
  TError = ErrorType<string>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof initiateEmailVerification>>,
    TError,
    { data: BodyType<EmailVerificationRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof initiateEmailVerification>>,
  TError,
  { data: BodyType<EmailVerificationRequest> },
  TContext
> => {
  const mutationKey = ["initiateEmailVerification"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof initiateEmailVerification>>,
    { data: BodyType<EmailVerificationRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return initiateEmailVerification(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type InitiateEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof initiateEmailVerification>>
>;
export type InitiateEmailVerificationMutationBody =
  BodyType<EmailVerificationRequest>;
export type InitiateEmailVerificationMutationError = ErrorType<string>;

/**
 * @summary Initiate email verification
 */
export const useInitiateEmailVerification = <
  TError = ErrorType<string>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof initiateEmailVerification>>,
      TError,
      { data: BodyType<EmailVerificationRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof initiateEmailVerification>>,
  TError,
  { data: BodyType<EmailVerificationRequest> },
  TContext
> => {
  const mutationOptions = getInitiateEmailVerificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Verifies the user's email address using a valid verification token
 * @summary Confirm email verification
 */
export const confirmEmailVerification = (
  params: MaybeRef<ConfirmEmailVerificationParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstance<string>({
    url: `/api/users/email/verify/confirm`,
    method: "POST",
    params: unref(params),
    signal,
  });
};

export const getConfirmEmailVerificationMutationOptions = <
  TError = ErrorType<string>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    TError,
    { params: ConfirmEmailVerificationParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { params: ConfirmEmailVerificationParams },
  TContext
> => {
  const mutationKey = ["confirmEmailVerification"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmEmailVerification>>,
    { params: ConfirmEmailVerificationParams }
  > = (props) => {
    const { params } = props ?? {};

    return confirmEmailVerification(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmEmailVerificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmEmailVerification>>
>;

export type ConfirmEmailVerificationMutationError = ErrorType<string>;

/**
 * @summary Confirm email verification
 */
export const useConfirmEmailVerification = <
  TError = ErrorType<string>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmEmailVerification>>,
      TError,
      { params: ConfirmEmailVerificationParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof confirmEmailVerification>>,
  TError,
  { params: ConfirmEmailVerificationParams },
  TContext
> => {
  const mutationOptions = getConfirmEmailVerificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve all roles
 * @summary Get all roles
 */
export const getAllRoles = (signal?: AbortSignal) => {
  return customInstance<RoleResponse[]>({
    url: `/api/roles`,
    method: "GET",
    signal,
  });
};

export const getGetAllRolesQueryKey = () => {
  return ["api", "roles"] as const;
};

export const getGetAllRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllRoles>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAllRolesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRoles>>> = ({
    signal,
  }) => getAllRoles(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllRoles>>,
    TError,
    TData
  >;
};

export type GetAllRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllRoles>>
>;
export type GetAllRolesQueryError = ErrorType<unknown>;

/**
 * @summary Get all roles
 */

export function useGetAllRoles<
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllRoles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllRolesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Create a new role
 * @summary Create a new role
 */
export const createRole = (
  createRoleRequest: MaybeRef<CreateRoleRequest>,
  signal?: AbortSignal,
) => {
  createRoleRequest = unref(createRoleRequest);

  return customInstance<RoleResponse>({
    url: `/api/roles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createRoleRequest,
    signal,
  });
};

export const getCreateRoleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRole>>,
    TError,
    { data: BodyType<CreateRoleRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  { data: BodyType<CreateRoleRequest> },
  TContext
> => {
  const mutationKey = ["createRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRole>>,
    { data: BodyType<CreateRoleRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createRole(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRole>>
>;
export type CreateRoleMutationBody = BodyType<CreateRoleRequest>;
export type CreateRoleMutationError = ErrorType<unknown>;

/**
 * @summary Create a new role
 */
export const useCreateRole = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRole>>,
      TError,
      { data: BodyType<CreateRoleRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  { data: BodyType<CreateRoleRequest> },
  TContext
> => {
  const mutationOptions = getCreateRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve all registered OAuth2 clients
 * @summary Get all OAuth2 clients
 */
export const getAllClients = (signal?: AbortSignal) => {
  return customInstance<GetAllClients200>({
    url: `/api/clients`,
    method: "GET",
    signal,
  });
};

export const getGetAllClientsQueryKey = () => {
  return ["api", "clients"] as const;
};

export const getGetAllClientsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllClients>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAllClientsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllClients>>> = ({
    signal,
  }) => getAllClients(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllClients>>,
    TError,
    TData
  >;
};

export type GetAllClientsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllClients>>
>;
export type GetAllClientsQueryError = ErrorType<unknown>;

/**
 * @summary Get all OAuth2 clients
 */

export function useGetAllClients<
  TData = Awaited<ReturnType<typeof getAllClients>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllClients>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllClientsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Create a new OAuth2 registered client
 * @summary Create a new OAuth2 client
 */
export const createClient = (
  createClientRequest: MaybeRef<CreateClientRequest>,
  signal?: AbortSignal,
) => {
  createClientRequest = unref(createClientRequest);

  return customInstance<ClientResponse>({
    url: `/api/clients`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createClientRequest,
    signal,
  });
};

export const getCreateClientMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createClient>>,
    TError,
    { data: BodyType<CreateClientRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createClient>>,
  TError,
  { data: BodyType<CreateClientRequest> },
  TContext
> => {
  const mutationKey = ["createClient"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createClient>>,
    { data: BodyType<CreateClientRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createClient(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateClientMutationResult = NonNullable<
  Awaited<ReturnType<typeof createClient>>
>;
export type CreateClientMutationBody = BodyType<CreateClientRequest>;
export type CreateClientMutationError = ErrorType<unknown>;

/**
 * @summary Create a new OAuth2 client
 */
export const useCreateClient = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createClient>>,
      TError,
      { data: BodyType<CreateClientRequest> },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof createClient>>,
  TError,
  { data: BodyType<CreateClientRequest> },
  TContext
> => {
  const mutationOptions = getCreateClientMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Generate a new client secret for an OAuth2 client
 * @summary Rotate client secret
 */
export const rotateClientSecret = (
  clientId: MaybeRef<string>,
  signal?: AbortSignal,
) => {
  clientId = unref(clientId);

  return customInstance<RotateClientSecret200>({
    url: `/api/clients/${clientId}/secret`,
    method: "POST",
    signal,
  });
};

export const getRotateClientSecretMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rotateClientSecret>>,
    TError,
    { clientId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rotateClientSecret>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationKey = ["rotateClientSecret"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rotateClientSecret>>,
    { clientId: string }
  > = (props) => {
    const { clientId } = props ?? {};

    return rotateClientSecret(clientId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RotateClientSecretMutationResult = NonNullable<
  Awaited<ReturnType<typeof rotateClientSecret>>
>;

export type RotateClientSecretMutationError = ErrorType<unknown>;

/**
 * @summary Rotate client secret
 */
export const useRotateClientSecret = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rotateClientSecret>>,
      TError,
      { clientId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof rotateClientSecret>>,
  TError,
  { clientId: string },
  TContext
> => {
  const mutationOptions = getRotateClientSecretMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Enable a user account
 * @summary Enable user
 */
export const enableUser = (id: MaybeRef<string>) => {
  id = unref(id);

  return customInstance<void>({
    url: `/api/users/${id}/enable`,
    method: "PATCH",
  });
};

export const getEnableUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof enableUser>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof enableUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["enableUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof enableUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return enableUser(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type EnableUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof enableUser>>
>;

export type EnableUserMutationError = ErrorType<unknown>;

/**
 * @summary Enable user
 */
export const useEnableUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof enableUser>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof enableUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getEnableUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Disable a user account
 * @summary Disable user
 */
export const disableUser = (id: MaybeRef<string>) => {
  id = unref(id);

  return customInstance<void>({
    url: `/api/users/${id}/disable`,
    method: "PATCH",
  });
};

export const getDisableUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disableUser>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof disableUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["disableUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disableUser>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return disableUser(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DisableUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof disableUser>>
>;

export type DisableUserMutationError = ErrorType<unknown>;

/**
 * @summary Disable user
 */
export const useDisableUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof disableUser>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof disableUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDisableUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns claims about the authenticated user
 * @summary Get user info
 */
export const getUserInfo = (signal?: AbortSignal) => {
  return customInstance<UserInfoResponse>({
    url: `/userinfo`,
    method: "GET",
    signal,
  });
};

export const getGetUserInfoQueryKey = () => {
  return ["userinfo"] as const;
};

export const getGetUserInfoQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserInfo>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetUserInfoQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserInfo>>> = ({
    signal,
  }) => getUserInfo(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserInfo>>,
    TError,
    TData
  >;
};

export type GetUserInfoQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserInfo>>
>;
export type GetUserInfoQueryError = ErrorType<unknown>;

/**
 * @summary Get user info
 */

export function useGetUserInfo<
  TData = Awaited<ReturnType<typeof getUserInfo>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserInfo>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserInfoQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Retrieve a specific role by name
 * @summary Get role by name
 */
export const getRoleByName = (name: MaybeRef<string>, signal?: AbortSignal) => {
  name = unref(name);

  return customInstance<RoleResponse>({
    url: `/api/roles/name/${name}`,
    method: "GET",
    signal,
  });
};

export const getGetRoleByNameQueryKey = (name?: MaybeRef<string>) => {
  return ["api", "roles", "name", name] as const;
};

export const getGetRoleByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoleByName>>,
  TError = ErrorType<unknown>,
>(
  name: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleByName>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetRoleByNameQueryKey(name);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleByName>>> = ({
    signal,
  }) => getRoleByName(name, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(name)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRoleByName>>,
    TError,
    TData
  >;
};

export type GetRoleByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoleByName>>
>;
export type GetRoleByNameQueryError = ErrorType<unknown>;

/**
 * @summary Get role by name
 */

export function useGetRoleByName<
  TData = Awaited<ReturnType<typeof getRoleByName>>,
  TError = ErrorType<unknown>,
>(
  name: MaybeRef<string>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleByName>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoleByNameQueryOptions(name, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Actuator root web endpoint
 */
export const links = (signal?: AbortSignal) => {
  return customInstance<Links200One | Links200Two | Links200Three>({
    url: `/actuator`,
    method: "GET",
    signal,
  });
};

export const getLinksQueryKey = () => {
  return ["actuator"] as const;
};

export const getLinksQueryOptions = <
  TData = Awaited<ReturnType<typeof links>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof links>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getLinksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof links>>> = ({
    signal,
  }) => links(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof links>>,
    TError,
    TData
  >;
};

export type LinksQueryResult = NonNullable<Awaited<ReturnType<typeof links>>>;
export type LinksQueryError = ErrorType<unknown>;

/**
 * @summary Actuator root web endpoint
 */

export function useLinks<
  TData = Awaited<ReturnType<typeof links>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof links>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getLinksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Actuator web endpoint 'health'
 */
export const health = (signal?: AbortSignal) => {
  return customInstance<Health200One | Health200Two | Health200Three>({
    url: `/actuator/health`,
    method: "GET",
    signal,
  });
};

export const getHealthQueryKey = () => {
  return ["actuator", "health"] as const;
};

export const getHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof health>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getHealthQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof health>>> = ({
    signal,
  }) => health(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof health>>,
    TError,
    TData
  >;
};

export type HealthQueryResult = NonNullable<Awaited<ReturnType<typeof health>>>;
export type HealthQueryError = ErrorType<unknown>;

/**
 * @summary Actuator web endpoint 'health'
 */

export function useHealth<
  TData = Awaited<ReturnType<typeof health>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof health>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * Remove a specific role from a user
 * @summary Remove role from user
 */
export const removeRole = (id: MaybeRef<string>, roleId: MaybeRef<string>) => {
  id = unref(id);
  roleId = unref(roleId);

  return customInstance<void>({
    url: `/api/users/${id}/roles/${roleId}`,
    method: "DELETE",
  });
};

export const getRemoveRoleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeRole>>,
    TError,
    { id: string; roleId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeRole>>,
  TError,
  { id: string; roleId: string },
  TContext
> => {
  const mutationKey = ["removeRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeRole>>,
    { id: string; roleId: string }
  > = (props) => {
    const { id, roleId } = props ?? {};

    return removeRole(id, roleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeRole>>
>;

export type RemoveRoleMutationError = ErrorType<unknown>;

/**
 * @summary Remove role from user
 */
export const useRemoveRole = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeRole>>,
      TError,
      { id: string; roleId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof removeRole>>,
  TError,
  { id: string; roleId: string },
  TContext
> => {
  const mutationOptions = getRemoveRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
