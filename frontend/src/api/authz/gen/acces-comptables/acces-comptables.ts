/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from '@tanstack/vue-query'
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'

import { computed, unref } from 'vue'
import type { MaybeRef } from 'vue'

import type {
  AssignComptableToSocieteRequest,
  ComptableSocietesDto,
  HasAccessParams,
  HasValidateAccessParams,
  HasWriteAccessParams,
  SocieteDto,
  UpdateComptableSocieteAccessRequest,
} from '../generated.schemas'

import { customInstance } from '../../../axios-instance'
import type { ErrorType, BodyType } from '../../../axios-instance'

/**
 * Recupere les details d'un acces par son ID
 * @summary Recuperer un acces
 */
export const findById2 = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id)

  return customInstance<ComptableSocietesDto>({
    url: `/api/comptable-societes/${id}`,
    method: 'GET',
    signal,
  })
}

export const getFindById2QueryKey = (id?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', id] as const
}

export const getFindById2QueryOptions = <
  TData = Awaited<ReturnType<typeof findById2>>,
  TError = ErrorType<ComptableSocietesDto>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findById2>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindById2QueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findById2>>> = ({ signal }) =>
    findById2(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findById2>>, TError, TData>
}

export type FindById2QueryResult = NonNullable<Awaited<ReturnType<typeof findById2>>>
export type FindById2QueryError = ErrorType<ComptableSocietesDto>

/**
 * @summary Recuperer un acces
 */

export function useFindById2<
  TData = Awaited<ReturnType<typeof findById2>>,
  TError = ErrorType<ComptableSocietesDto>,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findById2>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindById2QueryOptions(id, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Met a jour les droits d'un comptable sur une societe
 * @summary Modifier les droits d'acces
 */
export const updateAccess = (
  id: MaybeRef<number>,
  updateComptableSocieteAccessRequest: MaybeRef<UpdateComptableSocieteAccessRequest>
) => {
  id = unref(id)
  updateComptableSocieteAccessRequest = unref(updateComptableSocieteAccessRequest)

  return customInstance<ComptableSocietesDto>({
    url: `/api/comptable-societes/${id}`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    data: updateComptableSocieteAccessRequest,
  })
}

export const getUpdateAccessMutationOptions = <
  TError = ErrorType<ComptableSocietesDto>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccess>>,
    TError,
    { id: number; data: BodyType<UpdateComptableSocieteAccessRequest> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccess>>,
  TError,
  { id: number; data: BodyType<UpdateComptableSocieteAccessRequest> },
  TContext
> => {
  const mutationKey = ['updateAccess']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccess>>,
    { id: number; data: BodyType<UpdateComptableSocieteAccessRequest> }
  > = (props) => {
    const { id, data } = props ?? {}

    return updateAccess(id, data)
  }

  return { mutationFn, ...mutationOptions }
}

export type UpdateAccessMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccess>>>
export type UpdateAccessMutationBody = BodyType<UpdateComptableSocieteAccessRequest>
export type UpdateAccessMutationError = ErrorType<ComptableSocietesDto>

/**
 * @summary Modifier les droits d'acces
 */
export const useUpdateAccess = <TError = ErrorType<ComptableSocietesDto>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccess>>,
      TError,
      { id: number; data: BodyType<UpdateComptableSocieteAccessRequest> },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationReturnType<
  Awaited<ReturnType<typeof updateAccess>>,
  TError,
  { id: number; data: BodyType<UpdateComptableSocieteAccessRequest> },
  TContext
> => {
  const mutationOptions = getUpdateAccessMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Donne acces a un comptable sur une societe cliente
 * @summary Assigner un comptable a une societe
 */
export const assignComptableToSociete = (
  assignComptableToSocieteRequest: MaybeRef<AssignComptableToSocieteRequest>,
  signal?: AbortSignal
) => {
  assignComptableToSocieteRequest = unref(assignComptableToSocieteRequest)

  return customInstance<ComptableSocietesDto>({
    url: `/api/comptable-societes`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: assignComptableToSocieteRequest,
    signal,
  })
}

export const getAssignComptableToSocieteMutationOptions = <
  TError = ErrorType<ComptableSocietesDto>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof assignComptableToSociete>>,
    TError,
    { data: BodyType<AssignComptableToSocieteRequest> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof assignComptableToSociete>>,
  TError,
  { data: BodyType<AssignComptableToSocieteRequest> },
  TContext
> => {
  const mutationKey = ['assignComptableToSociete']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof assignComptableToSociete>>,
    { data: BodyType<AssignComptableToSocieteRequest> }
  > = (props) => {
    const { data } = props ?? {}

    return assignComptableToSociete(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AssignComptableToSocieteMutationResult = NonNullable<
  Awaited<ReturnType<typeof assignComptableToSociete>>
>
export type AssignComptableToSocieteMutationBody = BodyType<AssignComptableToSocieteRequest>
export type AssignComptableToSocieteMutationError = ErrorType<ComptableSocietesDto>

/**
 * @summary Assigner un comptable a une societe
 */
export const useAssignComptableToSociete = <
  TError = ErrorType<ComptableSocietesDto>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof assignComptableToSociete>>,
      TError,
      { data: BodyType<AssignComptableToSocieteRequest> },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationReturnType<
  Awaited<ReturnType<typeof assignComptableToSociete>>,
  TError,
  { data: BodyType<AssignComptableToSocieteRequest> },
  TContext
> => {
  const mutationOptions = getAssignComptableToSocieteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Recupere tous les acces d'un comptable
 * @summary Lister les acces d'un utilisateur
 */
export const findByUserId2 = (userId: MaybeRef<number>, signal?: AbortSignal) => {
  userId = unref(userId)

  return customInstance<ComptableSocietesDto[]>({
    url: `/api/comptable-societes/user/${userId}`,
    method: 'GET',
    signal,
  })
}

export const getFindByUserId2QueryKey = (userId?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', 'user', userId] as const
}

export const getFindByUserId2QueryOptions = <
  TData = Awaited<ReturnType<typeof findByUserId2>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findByUserId2>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindByUserId2QueryKey(userId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findByUserId2>>> = ({ signal }) =>
    findByUserId2(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findByUserId2>>, TError, TData>
}

export type FindByUserId2QueryResult = NonNullable<Awaited<ReturnType<typeof findByUserId2>>>
export type FindByUserId2QueryError = ErrorType<unknown>

/**
 * @summary Lister les acces d'un utilisateur
 */

export function useFindByUserId2<
  TData = Awaited<ReturnType<typeof findByUserId2>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findByUserId2>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindByUserId2QueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Recupere les societes auxquelles un comptable a acces
 * @summary Lister les societes accessibles
 */
export const findSocietesByUserId = (userId: MaybeRef<number>, signal?: AbortSignal) => {
  userId = unref(userId)

  return customInstance<SocieteDto[]>({
    url: `/api/comptable-societes/user/${userId}/societes`,
    method: 'GET',
    signal,
  })
}

export const getFindSocietesByUserIdQueryKey = (userId?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', 'user', userId, 'societes'] as const
}

export const getFindSocietesByUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findSocietesByUserId>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSocietesByUserId>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindSocietesByUserIdQueryKey(userId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findSocietesByUserId>>> = ({ signal }) =>
    findSocietesByUserId(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findSocietesByUserId>>, TError, TData>
}

export type FindSocietesByUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findSocietesByUserId>>
>
export type FindSocietesByUserIdQueryError = ErrorType<unknown>

/**
 * @summary Lister les societes accessibles
 */

export function useFindSocietesByUserId<
  TData = Awaited<ReturnType<typeof findSocietesByUserId>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSocietesByUserId>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindSocietesByUserIdQueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Recupere les societes o√π le comptable a le droit d'ecriture
 * @summary Lister les societes en ecriture
 */
export const findSocietesWithWriteAccessByUserId = (
  userId: MaybeRef<number>,
  signal?: AbortSignal
) => {
  userId = unref(userId)

  return customInstance<SocieteDto[]>({
    url: `/api/comptable-societes/user/${userId}/societes/write`,
    method: 'GET',
    signal,
  })
}

export const getFindSocietesWithWriteAccessByUserIdQueryKey = (userId?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', 'user', userId, 'societes', 'write'] as const
}

export const getFindSocietesWithWriteAccessByUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>,
        TError,
        TData
      >
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindSocietesWithWriteAccessByUserIdQueryKey(userId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>> = ({
    signal,
  }) => findSocietesWithWriteAccessByUserId(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>,
    TError,
    TData
  >
}

export type FindSocietesWithWriteAccessByUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>
>
export type FindSocietesWithWriteAccessByUserIdQueryError = ErrorType<unknown>

/**
 * @summary Lister les societes en ecriture
 */

export function useFindSocietesWithWriteAccessByUserId<
  TData = Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findSocietesWithWriteAccessByUserId>>,
        TError,
        TData
      >
    >
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindSocietesWithWriteAccessByUserIdQueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Recupere l'acces d'un utilisateur sur une societe
 * @summary Recuperer l'acces utilisateur-societe
 */
export const findByUserIdAndSocieteId = (
  userId: MaybeRef<number>,
  societeId: MaybeRef<number>,
  signal?: AbortSignal
) => {
  userId = unref(userId)
  societeId = unref(societeId)

  return customInstance<ComptableSocietesDto>({
    url: `/api/comptable-societes/user/${userId}/societe/${societeId}`,
    method: 'GET',
    signal,
  })
}

export const getFindByUserIdAndSocieteIdQueryKey = (
  userId?: MaybeRef<number>,
  societeId?: MaybeRef<number>
) => {
  return ['api', 'comptable-societes', 'user', userId, 'societe', societeId] as const
}

export const getFindByUserIdAndSocieteIdQueryOptions = <
  TData = Awaited<ReturnType<typeof findByUserIdAndSocieteId>>,
  TError = ErrorType<ComptableSocietesDto>,
>(
  userId: MaybeRef<number>,
  societeId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByUserIdAndSocieteId>>, TError, TData>
    >
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindByUserIdAndSocieteIdQueryKey(userId, societeId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findByUserIdAndSocieteId>>> = ({
    signal,
  }) => findByUserIdAndSocieteId(userId, societeId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!(unref(userId) && unref(societeId))),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findByUserIdAndSocieteId>>, TError, TData>
}

export type FindByUserIdAndSocieteIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof findByUserIdAndSocieteId>>
>
export type FindByUserIdAndSocieteIdQueryError = ErrorType<ComptableSocietesDto>

/**
 * @summary Recuperer l'acces utilisateur-societe
 */

export function useFindByUserIdAndSocieteId<
  TData = Awaited<ReturnType<typeof findByUserIdAndSocieteId>>,
  TError = ErrorType<ComptableSocietesDto>,
>(
  userId: MaybeRef<number>,
  societeId: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByUserIdAndSocieteId>>, TError, TData>
    >
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindByUserIdAndSocieteIdQueryOptions(userId, societeId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Revoque l'acces d'un comptable a une societe
 * @summary Revoquer l'acces
 */
export const revokeAccess = (userId: MaybeRef<number>, societeId: MaybeRef<number>) => {
  userId = unref(userId)
  societeId = unref(societeId)

  return customInstance<void>({
    url: `/api/comptable-societes/user/${userId}/societe/${societeId}`,
    method: 'DELETE',
  })
}

export const getRevokeAccessMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeAccess>>,
    TError,
    { userId: number; societeId: number },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof revokeAccess>>,
  TError,
  { userId: number; societeId: number },
  TContext
> => {
  const mutationKey = ['revokeAccess']
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeAccess>>,
    { userId: number; societeId: number }
  > = (props) => {
    const { userId, societeId } = props ?? {}

    return revokeAccess(userId, societeId)
  }

  return { mutationFn, ...mutationOptions }
}

export type RevokeAccessMutationResult = NonNullable<Awaited<ReturnType<typeof revokeAccess>>>

export type RevokeAccessMutationError = ErrorType<void>

/**
 * @summary Revoquer l'acces
 */
export const useRevokeAccess = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revokeAccess>>,
      TError,
      { userId: number; societeId: number },
      TContext
    >
  },
  queryClient?: QueryClient
): UseMutationReturnType<
  Awaited<ReturnType<typeof revokeAccess>>,
  TError,
  { userId: number; societeId: number },
  TContext
> => {
  const mutationOptions = getRevokeAccessMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Recupere les acces actifs d'un comptable
 * @summary Lister les acces actifs
 */
export const findActiveByUserId2 = (userId: MaybeRef<number>, signal?: AbortSignal) => {
  userId = unref(userId)

  return customInstance<ComptableSocietesDto[]>({
    url: `/api/comptable-societes/user/${userId}/active`,
    method: 'GET',
    signal,
  })
}

export const getFindActiveByUserId2QueryKey = (userId?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', 'user', userId, 'active'] as const
}

export const getFindActiveByUserId2QueryOptions = <
  TData = Awaited<ReturnType<typeof findActiveByUserId2>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findActiveByUserId2>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindActiveByUserId2QueryKey(userId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findActiveByUserId2>>> = ({ signal }) =>
    findActiveByUserId2(userId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(userId)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findActiveByUserId2>>, TError, TData>
}

export type FindActiveByUserId2QueryResult = NonNullable<
  Awaited<ReturnType<typeof findActiveByUserId2>>
>
export type FindActiveByUserId2QueryError = ErrorType<unknown>

/**
 * @summary Lister les acces actifs
 */

export function useFindActiveByUserId2<
  TData = Awaited<ReturnType<typeof findActiveByUserId2>>,
  TError = ErrorType<unknown>,
>(
  userId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findActiveByUserId2>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindActiveByUserId2QueryOptions(userId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Recupere tous les comptables ayant acces a une societe
 * @summary Lister les comptables d'une societe
 */
export const findBySocieteId1 = (societeId: MaybeRef<number>, signal?: AbortSignal) => {
  societeId = unref(societeId)

  return customInstance<ComptableSocietesDto[]>({
    url: `/api/comptable-societes/societe/${societeId}`,
    method: 'GET',
    signal,
  })
}

export const getFindBySocieteId1QueryKey = (societeId?: MaybeRef<number>) => {
  return ['api', 'comptable-societes', 'societe', societeId] as const
}

export const getFindBySocieteId1QueryOptions = <
  TData = Awaited<ReturnType<typeof findBySocieteId1>>,
  TError = ErrorType<unknown>,
>(
  societeId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findBySocieteId1>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getFindBySocieteId1QueryKey(societeId)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findBySocieteId1>>> = ({ signal }) =>
    findBySocieteId1(societeId, signal)

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(societeId)),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findBySocieteId1>>, TError, TData>
}

export type FindBySocieteId1QueryResult = NonNullable<Awaited<ReturnType<typeof findBySocieteId1>>>
export type FindBySocieteId1QueryError = ErrorType<unknown>

/**
 * @summary Lister les comptables d'une societe
 */

export function useFindBySocieteId1<
  TData = Awaited<ReturnType<typeof findBySocieteId1>>,
  TError = ErrorType<unknown>,
>(
  societeId: MaybeRef<number>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findBySocieteId1>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindBySocieteId1QueryOptions(societeId, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Verifie si un comptable a le droit d'ecriture sur une societe
 * @summary Verifier le droit d'ecriture
 */
export const hasWriteAccess = (params: MaybeRef<HasWriteAccessParams>, signal?: AbortSignal) => {
  params = unref(params)

  return customInstance<boolean>({
    url: `/api/comptable-societes/check/write`,
    method: 'GET',
    params: unref(params),
    signal,
  })
}

export const getHasWriteAccessQueryKey = (params?: MaybeRef<HasWriteAccessParams>) => {
  return ['api', 'comptable-societes', 'check', 'write', ...(params ? [params] : [])] as const
}

export const getHasWriteAccessQueryOptions = <
  TData = Awaited<ReturnType<typeof hasWriteAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasWriteAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasWriteAccess>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getHasWriteAccessQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof hasWriteAccess>>> = ({ signal }) =>
    hasWriteAccess(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof hasWriteAccess>>,
    TError,
    TData
  >
}

export type HasWriteAccessQueryResult = NonNullable<Awaited<ReturnType<typeof hasWriteAccess>>>
export type HasWriteAccessQueryError = ErrorType<unknown>

/**
 * @summary Verifier le droit d'ecriture
 */

export function useHasWriteAccess<
  TData = Awaited<ReturnType<typeof hasWriteAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasWriteAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasWriteAccess>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHasWriteAccessQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Verifie si un comptable a le droit de validation sur une societe
 * @summary Verifier le droit de validation
 */
export const hasValidateAccess = (
  params: MaybeRef<HasValidateAccessParams>,
  signal?: AbortSignal
) => {
  params = unref(params)

  return customInstance<boolean>({
    url: `/api/comptable-societes/check/validate`,
    method: 'GET',
    params: unref(params),
    signal,
  })
}

export const getHasValidateAccessQueryKey = (params?: MaybeRef<HasValidateAccessParams>) => {
  return ['api', 'comptable-societes', 'check', 'validate', ...(params ? [params] : [])] as const
}

export const getHasValidateAccessQueryOptions = <
  TData = Awaited<ReturnType<typeof hasValidateAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasValidateAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasValidateAccess>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getHasValidateAccessQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof hasValidateAccess>>> = ({ signal }) =>
    hasValidateAccess(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof hasValidateAccess>>,
    TError,
    TData
  >
}

export type HasValidateAccessQueryResult = NonNullable<
  Awaited<ReturnType<typeof hasValidateAccess>>
>
export type HasValidateAccessQueryError = ErrorType<unknown>

/**
 * @summary Verifier le droit de validation
 */

export function useHasValidateAccess<
  TData = Awaited<ReturnType<typeof hasValidateAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasValidateAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasValidateAccess>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHasValidateAccessQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}

/**
 * Verifie si un comptable a acces a une societe
 * @summary Verifier l'acces
 */
export const hasAccess = (params: MaybeRef<HasAccessParams>, signal?: AbortSignal) => {
  params = unref(params)

  return customInstance<boolean>({
    url: `/api/comptable-societes/check/access`,
    method: 'GET',
    params: unref(params),
    signal,
  })
}

export const getHasAccessQueryKey = (params?: MaybeRef<HasAccessParams>) => {
  return ['api', 'comptable-societes', 'check', 'access', ...(params ? [params] : [])] as const
}

export const getHasAccessQueryOptions = <
  TData = Awaited<ReturnType<typeof hasAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasAccess>>, TError, TData>>
  }
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = getHasAccessQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof hasAccess>>> = ({ signal }) =>
    hasAccess(params, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof hasAccess>>,
    TError,
    TData
  >
}

export type HasAccessQueryResult = NonNullable<Awaited<ReturnType<typeof hasAccess>>>
export type HasAccessQueryError = ErrorType<unknown>

/**
 * @summary Verifier l'acces
 */

export function useHasAccess<
  TData = Awaited<ReturnType<typeof hasAccess>>,
  TError = ErrorType<unknown>,
>(
  params: MaybeRef<HasAccessParams>,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof hasAccess>>, TError, TData>>
  },
  queryClient?: QueryClient
): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHasAccessQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>

  return query
}
