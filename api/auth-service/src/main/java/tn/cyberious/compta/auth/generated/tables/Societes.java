/*
 * This file is generated by jOOQ.
 */
package tn.cyberious.compta.auth.generated.tables;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.Index;
import org.jooq.InverseForeignKey;
import org.jooq.Name;
import org.jooq.Path;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;
import tn.cyberious.compta.auth.generated.Auth;
import tn.cyberious.compta.auth.generated.Indexes;
import tn.cyberious.compta.auth.generated.Keys;
import tn.cyberious.compta.auth.generated.tables.ComptableSocietes.ComptableSocietesPath;
import tn.cyberious.compta.auth.generated.tables.Employees.EmployeesPath;
import tn.cyberious.compta.auth.generated.tables.UserSocietes.UserSocietesPath;
import tn.cyberious.compta.auth.generated.tables.Users.UsersPath;
import tn.cyberious.compta.auth.generated.tables.records.SocietesRecord;

/** This class is generated by jOOQ. */
@SuppressWarnings({"all", "unchecked", "rawtypes", "this-escape"})
public class Societes extends TableImpl<SocietesRecord> {

  private static final long serialVersionUID = 1L;

  /** The reference instance of <code>auth.societes</code> */
  public static final Societes SOCIETES = new Societes();

  /** The class holding records for this type */
  @Override
  public Class<SocietesRecord> getRecordType() {
    return SocietesRecord.class;
  }

  /** The column <code>auth.societes.id</code>. */
  public final TableField<SocietesRecord, Long> ID =
      createField(DSL.name("id"), SQLDataType.BIGINT.nullable(false).identity(true), this, "");

  /** The column <code>auth.societes.raison_sociale</code>. */
  public final TableField<SocietesRecord, String> RAISON_SOCIALE =
      createField(DSL.name("raison_sociale"), SQLDataType.VARCHAR(255).nullable(false), this, "");

  /** The column <code>auth.societes.matricule_fiscale</code>. */
  public final TableField<SocietesRecord, String> MATRICULE_FISCALE =
      createField(DSL.name("matricule_fiscale"), SQLDataType.VARCHAR(13).nullable(false), this, "");

  /** The column <code>auth.societes.code_tva</code>. */
  public final TableField<SocietesRecord, String> CODE_TVA =
      createField(DSL.name("code_tva"), SQLDataType.VARCHAR(20), this, "");

  /** The column <code>auth.societes.code_douane</code>. */
  public final TableField<SocietesRecord, String> CODE_DOUANE =
      createField(DSL.name("code_douane"), SQLDataType.VARCHAR(20), this, "");

  /** The column <code>auth.societes.registre_commerce</code>. */
  public final TableField<SocietesRecord, String> REGISTRE_COMMERCE =
      createField(DSL.name("registre_commerce"), SQLDataType.VARCHAR(50), this, "");

  /** The column <code>auth.societes.forme_juridique</code>. */
  public final TableField<SocietesRecord, String> FORME_JURIDIQUE =
      createField(DSL.name("forme_juridique"), SQLDataType.VARCHAR(100), this, "");

  /** The column <code>auth.societes.capital_social</code>. */
  public final TableField<SocietesRecord, BigDecimal> CAPITAL_SOCIAL =
      createField(DSL.name("capital_social"), SQLDataType.NUMERIC(15, 2), this, "");

  /** The column <code>auth.societes.date_creation</code>. */
  public final TableField<SocietesRecord, LocalDate> DATE_CREATION =
      createField(DSL.name("date_creation"), SQLDataType.LOCALDATE, this, "");

  /** The column <code>auth.societes.adresse</code>. */
  public final TableField<SocietesRecord, String> ADRESSE =
      createField(DSL.name("adresse"), SQLDataType.VARCHAR(255), this, "");

  /** The column <code>auth.societes.ville</code>. */
  public final TableField<SocietesRecord, String> VILLE =
      createField(DSL.name("ville"), SQLDataType.VARCHAR(100), this, "");

  /** The column <code>auth.societes.code_postal</code>. */
  public final TableField<SocietesRecord, String> CODE_POSTAL =
      createField(DSL.name("code_postal"), SQLDataType.VARCHAR(10), this, "");

  /** The column <code>auth.societes.telephone</code>. */
  public final TableField<SocietesRecord, String> TELEPHONE =
      createField(DSL.name("telephone"), SQLDataType.VARCHAR(20), this, "");

  /** The column <code>auth.societes.fax</code>. */
  public final TableField<SocietesRecord, String> FAX =
      createField(DSL.name("fax"), SQLDataType.VARCHAR(20), this, "");

  /** The column <code>auth.societes.email</code>. */
  public final TableField<SocietesRecord, String> EMAIL =
      createField(DSL.name("email"), SQLDataType.VARCHAR(255), this, "");

  /** The column <code>auth.societes.site_web</code>. */
  public final TableField<SocietesRecord, String> SITE_WEB =
      createField(DSL.name("site_web"), SQLDataType.VARCHAR(255), this, "");

  /** The column <code>auth.societes.activite</code>. */
  public final TableField<SocietesRecord, String> ACTIVITE =
      createField(DSL.name("activite"), SQLDataType.VARCHAR(255), this, "");

  /** The column <code>auth.societes.secteur</code>. */
  public final TableField<SocietesRecord, String> SECTEUR =
      createField(DSL.name("secteur"), SQLDataType.VARCHAR(100), this, "");

  /** The column <code>auth.societes.is_active</code>. */
  public final TableField<SocietesRecord, Boolean> IS_ACTIVE =
      createField(
          DSL.name("is_active"),
          SQLDataType.BOOLEAN.defaultValue(DSL.field(DSL.raw("true"), SQLDataType.BOOLEAN)),
          this,
          "");

  /** The column <code>auth.societes.created_at</code>. */
  public final TableField<SocietesRecord, LocalDateTime> CREATED_AT =
      createField(
          DSL.name("created_at"),
          SQLDataType.LOCALDATETIME(6)
              .defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)),
          this,
          "");

  /** The column <code>auth.societes.updated_at</code>. */
  public final TableField<SocietesRecord, LocalDateTime> UPDATED_AT =
      createField(
          DSL.name("updated_at"),
          SQLDataType.LOCALDATETIME(6)
              .defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)),
          this,
          "");

  /** The column <code>auth.societes.created_by</code>. */
  public final TableField<SocietesRecord, Long> CREATED_BY =
      createField(DSL.name("created_by"), SQLDataType.BIGINT, this, "");

  /** The column <code>auth.societes.updated_by</code>. */
  public final TableField<SocietesRecord, Long> UPDATED_BY =
      createField(DSL.name("updated_by"), SQLDataType.BIGINT, this, "");

  private Societes(Name alias, Table<SocietesRecord> aliased) {
    this(alias, aliased, (Field<?>[]) null, null);
  }

  private Societes(
      Name alias, Table<SocietesRecord> aliased, Field<?>[] parameters, Condition where) {
    super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
  }

  /** Create an aliased <code>auth.societes</code> table reference */
  public Societes(String alias) {
    this(DSL.name(alias), SOCIETES);
  }

  /** Create an aliased <code>auth.societes</code> table reference */
  public Societes(Name alias) {
    this(alias, SOCIETES);
  }

  /** Create a <code>auth.societes</code> table reference */
  public Societes() {
    this(DSL.name("societes"), null);
  }

  public <O extends Record> Societes(
      Table<O> path,
      ForeignKey<O, SocietesRecord> childPath,
      InverseForeignKey<O, SocietesRecord> parentPath) {
    super(path, childPath, parentPath, SOCIETES);
  }

  /** A subtype implementing {@link Path} for simplified path-based joins. */
  public static class SocietesPath extends Societes implements Path<SocietesRecord> {

    private static final long serialVersionUID = 1L;

    public <O extends Record> SocietesPath(
        Table<O> path,
        ForeignKey<O, SocietesRecord> childPath,
        InverseForeignKey<O, SocietesRecord> parentPath) {
      super(path, childPath, parentPath);
    }

    private SocietesPath(Name alias, Table<SocietesRecord> aliased) {
      super(alias, aliased);
    }

    @Override
    public SocietesPath as(String alias) {
      return new SocietesPath(DSL.name(alias), this);
    }

    @Override
    public SocietesPath as(Name alias) {
      return new SocietesPath(alias, this);
    }

    @Override
    public SocietesPath as(Table<?> alias) {
      return new SocietesPath(alias.getQualifiedName(), this);
    }
  }

  @Override
  public Schema getSchema() {
    return aliased() ? null : Auth.AUTH;
  }

  @Override
  public List<Index> getIndexes() {
    return Arrays.asList(Indexes.IDX_SOCIETES_IS_ACTIVE, Indexes.IDX_SOCIETES_MATRICULE);
  }

  @Override
  public Identity<SocietesRecord, Long> getIdentity() {
    return (Identity<SocietesRecord, Long>) super.getIdentity();
  }

  @Override
  public UniqueKey<SocietesRecord> getPrimaryKey() {
    return Keys.SOCIETES_PKEY;
  }

  @Override
  public List<UniqueKey<SocietesRecord>> getUniqueKeys() {
    return Arrays.asList(Keys.SOCIETES_MATRICULE_FISCALE_KEY);
  }

  @Override
  public List<ForeignKey<SocietesRecord, ?>> getReferences() {
    return Arrays.asList(
        Keys.SOCIETES__SOCIETES_CREATED_BY_FKEY, Keys.SOCIETES__SOCIETES_UPDATED_BY_FKEY);
  }

  private transient UsersPath _societesCreatedByFkey;

  /**
   * Get the implicit join path to the <code>auth.users</code> table, via the <code>
   * societes_created_by_fkey</code> key.
   */
  public UsersPath societesCreatedByFkey() {
    if (_societesCreatedByFkey == null)
      _societesCreatedByFkey = new UsersPath(this, Keys.SOCIETES__SOCIETES_CREATED_BY_FKEY, null);

    return _societesCreatedByFkey;
  }

  private transient UsersPath _societesUpdatedByFkey;

  /**
   * Get the implicit join path to the <code>auth.users</code> table, via the <code>
   * societes_updated_by_fkey</code> key.
   */
  public UsersPath societesUpdatedByFkey() {
    if (_societesUpdatedByFkey == null)
      _societesUpdatedByFkey = new UsersPath(this, Keys.SOCIETES__SOCIETES_UPDATED_BY_FKEY, null);

    return _societesUpdatedByFkey;
  }

  private transient ComptableSocietesPath _comptableSocietes;

  /** Get the implicit to-many join path to the <code>auth.comptable_societes</code> table */
  public ComptableSocietesPath comptableSocietes() {
    if (_comptableSocietes == null)
      _comptableSocietes =
          new ComptableSocietesPath(
              this,
              null,
              Keys.COMPTABLE_SOCIETES__COMPTABLE_SOCIETES_SOCIETE_ID_FKEY.getInverseKey());

    return _comptableSocietes;
  }

  private transient EmployeesPath _employees;

  /** Get the implicit to-many join path to the <code>auth.employees</code> table */
  public EmployeesPath employees() {
    if (_employees == null)
      _employees =
          new EmployeesPath(this, null, Keys.EMPLOYEES__EMPLOYEES_SOCIETE_ID_FKEY.getInverseKey());

    return _employees;
  }

  private transient UserSocietesPath _userSocietes;

  /** Get the implicit to-many join path to the <code>auth.user_societes</code> table */
  public UserSocietesPath userSocietes() {
    if (_userSocietes == null)
      _userSocietes =
          new UserSocietesPath(
              this, null, Keys.USER_SOCIETES__USER_SOCIETES_SOCIETE_ID_FKEY.getInverseKey());

    return _userSocietes;
  }

  /**
   * Get the implicit many-to-many join path to the <code>auth.users</code> table, via the <code>
   * comptable_societes_user_id_fkey</code> key
   */
  public UsersPath comptableSocietesUserIdFkey() {
    return comptableSocietes().users();
  }

  /**
   * Get the implicit many-to-many join path to the <code>auth.users</code> table, via the <code>
   * user_societes_user_id_fkey</code> key
   */
  public UsersPath userSocietesUserIdFkey() {
    return userSocietes().users();
  }

  @Override
  public TableField<SocietesRecord, LocalDateTime> getRecordTimestamp() {
    return CREATED_AT;
  }

  @Override
  public Societes as(String alias) {
    return new Societes(DSL.name(alias), this);
  }

  @Override
  public Societes as(Name alias) {
    return new Societes(alias, this);
  }

  @Override
  public Societes as(Table<?> alias) {
    return new Societes(alias.getQualifiedName(), this);
  }

  /** Rename this table */
  @Override
  public Societes rename(String name) {
    return new Societes(DSL.name(name), null);
  }

  /** Rename this table */
  @Override
  public Societes rename(Name name) {
    return new Societes(name, null);
  }

  /** Rename this table */
  @Override
  public Societes rename(Table<?> name) {
    return new Societes(name.getQualifiedName(), null);
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes where(Condition condition) {
    return new Societes(getQualifiedName(), aliased() ? this : null, null, condition);
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes where(Collection<? extends Condition> conditions) {
    return where(DSL.and(conditions));
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes where(Condition... conditions) {
    return where(DSL.and(conditions));
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes where(Field<Boolean> condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Societes where(SQL condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Societes where(@Stringly.SQL String condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Societes where(@Stringly.SQL String condition, Object... binds) {
    return where(DSL.condition(condition, binds));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Societes where(@Stringly.SQL String condition, QueryPart... parts) {
    return where(DSL.condition(condition, parts));
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes whereExists(Select<?> select) {
    return where(DSL.exists(select));
  }

  /** Create an inline derived table from this table */
  @Override
  public Societes whereNotExists(Select<?> select) {
    return where(DSL.notExists(select));
  }
}
