/*
 * This file is generated by jOOQ.
 */
package tn.cyberious.compta.auth.generated.tables;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.jooq.Condition;
import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Identity;
import org.jooq.Index;
import org.jooq.InverseForeignKey;
import org.jooq.Name;
import org.jooq.Path;
import org.jooq.PlainSQL;
import org.jooq.QueryPart;
import org.jooq.Record;
import org.jooq.SQL;
import org.jooq.Schema;
import org.jooq.Select;
import org.jooq.Stringly;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.TableOptions;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;
import tn.cyberious.compta.auth.generated.Auth;
import tn.cyberious.compta.auth.generated.Indexes;
import tn.cyberious.compta.auth.generated.Keys;
import tn.cyberious.compta.auth.generated.tables.AuthLogs.AuthLogsPath;
import tn.cyberious.compta.auth.generated.tables.ComptableSocietes.ComptableSocietesPath;
import tn.cyberious.compta.auth.generated.tables.Employees.EmployeesPath;
import tn.cyberious.compta.auth.generated.tables.RefreshTokens.RefreshTokensPath;
import tn.cyberious.compta.auth.generated.tables.Roles.RolesPath;
import tn.cyberious.compta.auth.generated.tables.Societes.SocietesPath;
import tn.cyberious.compta.auth.generated.tables.UserRoles.UserRolesPath;
import tn.cyberious.compta.auth.generated.tables.UserSocietes.UserSocietesPath;
import tn.cyberious.compta.auth.generated.tables.records.UsersRecord;

/** This class is generated by jOOQ. */
@SuppressWarnings({"all", "unchecked", "rawtypes", "this-escape"})
public class Users extends TableImpl<UsersRecord> {

  private static final long serialVersionUID = 1L;

  /** The reference instance of <code>auth.users</code> */
  public static final Users USERS = new Users();

  /** The class holding records for this type */
  @Override
  public Class<UsersRecord> getRecordType() {
    return UsersRecord.class;
  }

  /** The column <code>auth.users.id</code>. */
  public final TableField<UsersRecord, Long> ID =
      createField(DSL.name("id"), SQLDataType.BIGINT.nullable(false).identity(true), this, "");

  /** The column <code>auth.users.username</code>. */
  public final TableField<UsersRecord, String> USERNAME =
      createField(DSL.name("username"), SQLDataType.VARCHAR(100).nullable(false), this, "");

  /** The column <code>auth.users.email</code>. */
  public final TableField<UsersRecord, String> EMAIL =
      createField(DSL.name("email"), SQLDataType.VARCHAR(255).nullable(false), this, "");

  /** The column <code>auth.users.password</code>. */
  public final TableField<UsersRecord, String> PASSWORD =
      createField(DSL.name("password"), SQLDataType.VARCHAR(255).nullable(false), this, "");

  /** The column <code>auth.users.first_name</code>. */
  public final TableField<UsersRecord, String> FIRST_NAME =
      createField(DSL.name("first_name"), SQLDataType.VARCHAR(100), this, "");

  /** The column <code>auth.users.last_name</code>. */
  public final TableField<UsersRecord, String> LAST_NAME =
      createField(DSL.name("last_name"), SQLDataType.VARCHAR(100), this, "");

  /** The column <code>auth.users.phone</code>. */
  public final TableField<UsersRecord, String> PHONE =
      createField(DSL.name("phone"), SQLDataType.VARCHAR(20), this, "");

  /** The column <code>auth.users.is_active</code>. */
  public final TableField<UsersRecord, Boolean> IS_ACTIVE =
      createField(
          DSL.name("is_active"),
          SQLDataType.BOOLEAN.defaultValue(DSL.field(DSL.raw("true"), SQLDataType.BOOLEAN)),
          this,
          "");

  /** The column <code>auth.users.is_locked</code>. */
  public final TableField<UsersRecord, Boolean> IS_LOCKED =
      createField(
          DSL.name("is_locked"),
          SQLDataType.BOOLEAN.defaultValue(DSL.field(DSL.raw("false"), SQLDataType.BOOLEAN)),
          this,
          "");

  /** The column <code>auth.users.failed_login_attempts</code>. */
  public final TableField<UsersRecord, Integer> FAILED_LOGIN_ATTEMPTS =
      createField(
          DSL.name("failed_login_attempts"),
          SQLDataType.INTEGER.defaultValue(DSL.field(DSL.raw("0"), SQLDataType.INTEGER)),
          this,
          "");

  /** The column <code>auth.users.last_login_at</code>. */
  public final TableField<UsersRecord, LocalDateTime> LAST_LOGIN_AT =
      createField(DSL.name("last_login_at"), SQLDataType.LOCALDATETIME(6), this, "");

  /** The column <code>auth.users.password_changed_at</code>. */
  public final TableField<UsersRecord, LocalDateTime> PASSWORD_CHANGED_AT =
      createField(DSL.name("password_changed_at"), SQLDataType.LOCALDATETIME(6), this, "");

  /** The column <code>auth.users.created_at</code>. */
  public final TableField<UsersRecord, LocalDateTime> CREATED_AT =
      createField(
          DSL.name("created_at"),
          SQLDataType.LOCALDATETIME(6)
              .defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)),
          this,
          "");

  /** The column <code>auth.users.updated_at</code>. */
  public final TableField<UsersRecord, LocalDateTime> UPDATED_AT =
      createField(
          DSL.name("updated_at"),
          SQLDataType.LOCALDATETIME(6)
              .defaultValue(DSL.field(DSL.raw("CURRENT_TIMESTAMP"), SQLDataType.LOCALDATETIME)),
          this,
          "");

  /** The column <code>auth.users.created_by</code>. */
  public final TableField<UsersRecord, Long> CREATED_BY =
      createField(DSL.name("created_by"), SQLDataType.BIGINT, this, "");

  /** The column <code>auth.users.updated_by</code>. */
  public final TableField<UsersRecord, Long> UPDATED_BY =
      createField(DSL.name("updated_by"), SQLDataType.BIGINT, this, "");

  private Users(Name alias, Table<UsersRecord> aliased) {
    this(alias, aliased, (Field<?>[]) null, null);
  }

  private Users(Name alias, Table<UsersRecord> aliased, Field<?>[] parameters, Condition where) {
    super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
  }

  /** Create an aliased <code>auth.users</code> table reference */
  public Users(String alias) {
    this(DSL.name(alias), USERS);
  }

  /** Create an aliased <code>auth.users</code> table reference */
  public Users(Name alias) {
    this(alias, USERS);
  }

  /** Create a <code>auth.users</code> table reference */
  public Users() {
    this(DSL.name("users"), null);
  }

  public <O extends Record> Users(
      Table<O> path,
      ForeignKey<O, UsersRecord> childPath,
      InverseForeignKey<O, UsersRecord> parentPath) {
    super(path, childPath, parentPath, USERS);
  }

  /** A subtype implementing {@link Path} for simplified path-based joins. */
  public static class UsersPath extends Users implements Path<UsersRecord> {

    private static final long serialVersionUID = 1L;

    public <O extends Record> UsersPath(
        Table<O> path,
        ForeignKey<O, UsersRecord> childPath,
        InverseForeignKey<O, UsersRecord> parentPath) {
      super(path, childPath, parentPath);
    }

    private UsersPath(Name alias, Table<UsersRecord> aliased) {
      super(alias, aliased);
    }

    @Override
    public UsersPath as(String alias) {
      return new UsersPath(DSL.name(alias), this);
    }

    @Override
    public UsersPath as(Name alias) {
      return new UsersPath(alias, this);
    }

    @Override
    public UsersPath as(Table<?> alias) {
      return new UsersPath(alias.getQualifiedName(), this);
    }
  }

  @Override
  public Schema getSchema() {
    return aliased() ? null : Auth.AUTH;
  }

  @Override
  public List<Index> getIndexes() {
    return Arrays.asList(
        Indexes.IDX_USERS_EMAIL, Indexes.IDX_USERS_IS_ACTIVE, Indexes.IDX_USERS_USERNAME);
  }

  @Override
  public Identity<UsersRecord, Long> getIdentity() {
    return (Identity<UsersRecord, Long>) super.getIdentity();
  }

  @Override
  public UniqueKey<UsersRecord> getPrimaryKey() {
    return Keys.USERS_PKEY;
  }

  @Override
  public List<UniqueKey<UsersRecord>> getUniqueKeys() {
    return Arrays.asList(Keys.USERS_EMAIL_KEY, Keys.USERS_USERNAME_KEY);
  }

  private transient AuthLogsPath _authLogs;

  /** Get the implicit to-many join path to the <code>auth.auth_logs</code> table */
  public AuthLogsPath authLogs() {
    if (_authLogs == null)
      _authLogs =
          new AuthLogsPath(this, null, Keys.AUTH_LOGS__AUTH_LOGS_USER_ID_FKEY.getInverseKey());

    return _authLogs;
  }

  private transient ComptableSocietesPath _comptableSocietes;

  /** Get the implicit to-many join path to the <code>auth.comptable_societes</code> table */
  public ComptableSocietesPath comptableSocietes() {
    if (_comptableSocietes == null)
      _comptableSocietes =
          new ComptableSocietesPath(
              this, null, Keys.COMPTABLE_SOCIETES__COMPTABLE_SOCIETES_USER_ID_FKEY.getInverseKey());

    return _comptableSocietes;
  }

  private transient EmployeesPath _employees;

  /** Get the implicit to-many join path to the <code>auth.employees</code> table */
  public EmployeesPath employees() {
    if (_employees == null)
      _employees =
          new EmployeesPath(this, null, Keys.EMPLOYEES__EMPLOYEES_USER_ID_FKEY.getInverseKey());

    return _employees;
  }

  private transient RefreshTokensPath _refreshTokens;

  /** Get the implicit to-many join path to the <code>auth.refresh_tokens</code> table */
  public RefreshTokensPath refreshTokens() {
    if (_refreshTokens == null)
      _refreshTokens =
          new RefreshTokensPath(
              this, null, Keys.REFRESH_TOKENS__REFRESH_TOKENS_USER_ID_FKEY.getInverseKey());

    return _refreshTokens;
  }

  private transient SocietesPath _societesCreatedByFkey;

  /**
   * Get the implicit to-many join path to the <code>auth.societes</code> table, via the <code>
   * societes_created_by_fkey</code> key
   */
  public SocietesPath societesCreatedByFkey() {
    if (_societesCreatedByFkey == null)
      _societesCreatedByFkey =
          new SocietesPath(this, null, Keys.SOCIETES__SOCIETES_CREATED_BY_FKEY.getInverseKey());

    return _societesCreatedByFkey;
  }

  private transient SocietesPath _societesUpdatedByFkey;

  /**
   * Get the implicit to-many join path to the <code>auth.societes</code> table, via the <code>
   * societes_updated_by_fkey</code> key
   */
  public SocietesPath societesUpdatedByFkey() {
    if (_societesUpdatedByFkey == null)
      _societesUpdatedByFkey =
          new SocietesPath(this, null, Keys.SOCIETES__SOCIETES_UPDATED_BY_FKEY.getInverseKey());

    return _societesUpdatedByFkey;
  }

  private transient UserRolesPath _userRoles;

  /** Get the implicit to-many join path to the <code>auth.user_roles</code> table */
  public UserRolesPath userRoles() {
    if (_userRoles == null)
      _userRoles =
          new UserRolesPath(this, null, Keys.USER_ROLES__USER_ROLES_USER_ID_FKEY.getInverseKey());

    return _userRoles;
  }

  private transient UserSocietesPath _userSocietes;

  /** Get the implicit to-many join path to the <code>auth.user_societes</code> table */
  public UserSocietesPath userSocietes() {
    if (_userSocietes == null)
      _userSocietes =
          new UserSocietesPath(
              this, null, Keys.USER_SOCIETES__USER_SOCIETES_USER_ID_FKEY.getInverseKey());

    return _userSocietes;
  }

  /**
   * Get the implicit many-to-many join path to the <code>auth.societes</code> table, via the <code>
   * comptable_societes_societe_id_fkey</code> key
   */
  public SocietesPath comptableSocietesSocieteIdFkey() {
    return comptableSocietes().societes();
  }

  /** Get the implicit many-to-many join path to the <code>auth.roles</code> table */
  public RolesPath roles() {
    return userRoles().roles();
  }

  /**
   * Get the implicit many-to-many join path to the <code>auth.societes</code> table, via the <code>
   * user_societes_societe_id_fkey</code> key
   */
  public SocietesPath userSocietesSocieteIdFkey() {
    return userSocietes().societes();
  }

  @Override
  public TableField<UsersRecord, LocalDateTime> getRecordTimestamp() {
    return CREATED_AT;
  }

  @Override
  public Users as(String alias) {
    return new Users(DSL.name(alias), this);
  }

  @Override
  public Users as(Name alias) {
    return new Users(alias, this);
  }

  @Override
  public Users as(Table<?> alias) {
    return new Users(alias.getQualifiedName(), this);
  }

  /** Rename this table */
  @Override
  public Users rename(String name) {
    return new Users(DSL.name(name), null);
  }

  /** Rename this table */
  @Override
  public Users rename(Name name) {
    return new Users(name, null);
  }

  /** Rename this table */
  @Override
  public Users rename(Table<?> name) {
    return new Users(name.getQualifiedName(), null);
  }

  /** Create an inline derived table from this table */
  @Override
  public Users where(Condition condition) {
    return new Users(getQualifiedName(), aliased() ? this : null, null, condition);
  }

  /** Create an inline derived table from this table */
  @Override
  public Users where(Collection<? extends Condition> conditions) {
    return where(DSL.and(conditions));
  }

  /** Create an inline derived table from this table */
  @Override
  public Users where(Condition... conditions) {
    return where(DSL.and(conditions));
  }

  /** Create an inline derived table from this table */
  @Override
  public Users where(Field<Boolean> condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Users where(SQL condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Users where(@Stringly.SQL String condition) {
    return where(DSL.condition(condition));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Users where(@Stringly.SQL String condition, Object... binds) {
    return where(DSL.condition(condition, binds));
  }

  /** Create an inline derived table from this table */
  @Override
  @PlainSQL
  public Users where(@Stringly.SQL String condition, QueryPart... parts) {
    return where(DSL.condition(condition, parts));
  }

  /** Create an inline derived table from this table */
  @Override
  public Users whereExists(Select<?> select) {
    return where(DSL.exists(select));
  }

  /** Create an inline derived table from this table */
  @Override
  public Users whereNotExists(Select<?> select) {
    return where(DSL.notExists(select));
  }
}
