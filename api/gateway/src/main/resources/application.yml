server:
  port: 8080
  # ✅ Response compression configuration
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain,application/javascript,text/css
    min-response-size: 1024
  # ✅ Graceful shutdown
  shutdown: graceful

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      # ✅ Redis connection pool for rate limiting
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: -1ms
  application:
    name: gateway-service

  cloud:
    gateway.server.webflux:
      # ✅ Global Gateway settings
      httpclient:
        connect-timeout: 5000
        response-timeout: 30s
        pool:
          max-connections: 100
          max-idle-time: 30s
        # ✅ Request size limits to prevent DoS attacks
        max-initial-line-length: 8192
        max-header-size: 8192
        max-chunk-size: 8192
      routes:
        # ==========================================
        # Auth Service
        # ==========================================
        - id: auth-service
          uri: ${AUTH_SERVICE_URL:http://localhost:8081}
          predicates:
            - Path=/auth/**
          filters:
            # ✅ Circuit breaker with fallback
            - name: CircuitBreaker
              args:
                name: authService
                fallbackUri: forward:/fallback/auth
            # ✅ Rate limiting with Redis (10 requests/second, burst of 20)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 10000 # 10 seconds for login
        # ==========================================
        # Authorization Service
        # ==========================================
        - id: authz-service
          uri: ${AUTHZ_SERVICE_URL:http://localhost:8082}
          predicates:
            - Path=/authz/**
          filters:
            - name: CircuitBreaker
              args:
                name: authzService
                fallbackUri: forward:/fallback/authz
            # ✅ Rate limiting with Redis (20 requests/second, burst of 40)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 20
                redis-rate-limiter.burstCapacity: 40
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 5000

        # ==========================================
        # Invoice Service
        # ==========================================
        - id: invoice-service
          uri: ${INVOICE_SERVICE_URL:http://localhost:8083}
          predicates:
            - Path=/invoices/**
          filters:
            - name: CircuitBreaker
              args:
                name: invoiceService
                fallbackUri: forward:/fallback/invoices
            # ✅ Rate limiting with Redis (15 requests/second, burst of 30)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 15
                redis-rate-limiter.burstCapacity: 30
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 15000 # Longer timeout for invoice processing

        # ==========================================
        # Employee Service
        # ==========================================
        - id: employee-service
          uri: ${EMPLOYEE_SERVICE_URL:http://localhost:8084}
          predicates:
            - Path=/employees/**
          filters:
            - name: CircuitBreaker
              args:
                name: employeeService
                fallbackUri: forward:/fallback/employees
            # ✅ Rate limiting with Redis (20 requests/second, burst of 40)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 20
                redis-rate-limiter.burstCapacity: 40
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 5000

        # ==========================================
        # Document Service
        # ==========================================
        - id: document-service
          uri: ${DOCUMENT_SERVICE_URL:http://localhost:8085}
          predicates:
            - Path=/doc/**
          filters:
            - name: CircuitBreaker
              args:
                name: documentService
                fallbackUri: forward:/fallback/documents
            # ✅ Rate limiting with Redis (15 requests/second, burst of 30)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 15
                redis-rate-limiter.burstCapacity: 30
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 30000 # Longer timeout for file uploads

        # ==========================================
        # Referentiel Service
        # ==========================================
        - id: referentiel-service
          uri: ${REFERENTIEL_SERVICE_URL:http://localhost:8086}
          predicates:
            - Path=/referentiel/**
          filters:
            - name: CircuitBreaker
              args:
                name: referentielService
                fallbackUri: forward:/fallback/referentiel
            # ✅ Rate limiting with Redis (20 requests/second, burst of 40)
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 20
                redis-rate-limiter.burstCapacity: 40
                key-resolver: '#{@userKeyResolver}'
            # ✅ Retry strategy for transient errors
            - name: Retry
              args:
                retries: 3
                statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,PUT
                backoff:
                  firstBackoff: 10ms
                  maxBackoff: 50ms
                  factor: 2
                  basedOnPreviousValue: false
          metadata:
            response-timeout: 5000

  # ✅ CORS Configuration (externalized)
cors:
  allowed-origins:
    - http://localhost:3000
    - http://localhost:4200
    - http://localhost:8080
  max-age: 3600

# ✅ JWT Configuration
# ⚠️  In production, JWT_SECRET must be set via environment variable
# The default value is for development only - JwtConfigValidator blocks it in production
jwt:
  secret: ${JWT_SECRET:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}
  expiration: ${JWT_EXPIRATION:86400000} # 24 hours
  refresh-expiration: ${JWT_REFRESH_EXPIRATION:604800000} # 7 days

# ✅ OAuth2 Token Validation Configuration
# The gateway validates RSA JWT tokens issued by the OAuth2 server
oauth2:
  enabled: ${OAUTH2_TOKEN_VALIDATION_ENABLED:true}
  issuer: ${OAUTH2_ISSUER:http://localhost:9000}
  jwks-url: ${OAUTH2_JWKS_URL:http://localhost:9000/oauth2/jwks}
  jwks-cache-duration: ${OAUTH2_JWKS_CACHE_DURATION:300000} # 5 minutes
  validate-signature: ${OAUTH2_VALIDATE_SIGNATURE:true}
  cache-refresh-interval: ${OAUTH2_CACHE_REFRESH_INTERVAL:300000} # 5 minutes

# ✅ Gateway URLs pour OpenAPI
gateway:
  url:
    dev: http://localhost:8080
    prod: https://api.compta.tn

# ✅ Resilience4j Circuit Breaker
resilience4j:
  circuitbreaker:
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 30s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        slowCallDurationThreshold: 10s
        slowCallRateThreshold: 50
    instances:
      authService:
        baseConfig: default
        failureRateThreshold: 30
        waitDurationInOpenState: 60s
      authzService:
        baseConfig: default
        failureRateThreshold: 40
        waitDurationInOpenState: 30s
      invoiceService:
        baseConfig: default
        failureRateThreshold: 60
        slowCallDurationThreshold: 20s
      employeeService:
        baseConfig: default
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
      documentService:
        baseConfig: default
        failureRateThreshold: 50
        slowCallDurationThreshold: 30s
        waitDurationInOpenState: 30s
      referentielService:
        baseConfig: default
        failureRateThreshold: 50
        waitDurationInOpenState: 30s
  timelimiter:
    configs:
      default:
        timeoutDuration: 30s
    instances:
      authService:
        timeoutDuration: 10s
      authzService:
        timeoutDuration: 5s
      invoiceService:
        timeoutDuration: 60s
      employeeService:
        timeoutDuration: 10s
      documentService:
        timeoutDuration: 60s
      referentielService:
        timeoutDuration: 10s

  # Health check configuration
health:
  check:
    timeout-seconds: 5

# ✅ Swagger Configuration
springdoc:
  api-docs:
    enabled: true
    path: /v3/api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    urls:
      - name: Gateway
        url: /v3/api-docs
      - name: Auth Service
        url: /auth/v3/api-docs
      - name: Authz Service
        url: /authz/v3/api-docs
      - name: Invoice Service
        url: /invoices/v3/api-docs
      - name: Employee Service
        url: /employees/v3/api-docs
      - name: Document Service
        url: /doc/v3/api-docs
      - name: Referentiel Service
        url: /referentiel/v3/api-docs
    oauth2:
      use-pkce-with-authorization-code-grant: false

# ✅ Actuator Configuration
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,circuitbreakers,circuitbreakerevents
  endpoint:
    health:
      show-details: when-authorized
      show-components: when-authorized
  health:
    circuitbreakers:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name}
    distribution:
      percentiles-histogram:
        http.server.requests: true
  # ✅ Distributed Tracing (Micrometer)
  tracing:
    enabled: true
    sampling:
      probability: 1.0
    propagation:
      type: w3c

# ✅ Logging Configuration
logging:
  level:
    org.springframework.cloud.gateway: INFO
    org.springframework.security: INFO
    io.github.resilience4j: INFO
    tn.compta.gateway: DEBUG
  pattern:
    console: '%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - [traceId=%X{traceId} spanId=%X{spanId}] %msg%n'
